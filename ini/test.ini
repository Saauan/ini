

//declare type T1
//declare type T2
//declare type T extends T1, T2
declare test1() => T1 : [class="ini.Test1", member="new(..)"]
declare test2() => T2 : [class="ini.Test2", member="new(..)"]
declare m(T1) => Void : [class="this", member="m(..)"]
declare m(T2, String) => Void : [class="this", member="m(..)"]
//declare size(Test2) => Void : [class="this", member="m(..)"]

test1().m()
test2().m("tutu")

import "ini/lib/mongo.ini"

declare type Document = [key1:String,name:String]

println("start test")
c = mongoClient("localhost:27017")
println("connected")
//c.mongoDatabase("test").mongoCollection("test").insertOne(mongoParse("{key1:\"value\"}"))
//println("wrote document")
it = c.database("test").collection("test").find()
println(it)
println("===>"+it.firstDocument())

it.forEach(e => println(e))

println(Document[key1="hello",name="Renaud"])
println(document(Document[key1="hello",name="Renaud"]))

c.database("test").collection("test").insertOne(Document[key1="hello",name="Renaud"])
c.close()


/*
type Child = Boy[age:Int]
	| Girl[age:Int]
type Person = [name:String,firstName:String,age:Int,children:Child*]
declare channel +test_channel(Person)

function f(p) {
	case {
		//p of Person | !p.name || !p.firstName || !p.age {
		//	println("invalid person")
		//}
		p ~ Person[name=="renaud",firstName,!age] {
			println("Recieved INVALID person: {p.firstName} {p.name}, {p.age}")	
		}
		p ~ Boy[] {
			println("child {p.age}")
		}
		p ~ Person[name,firstName,age] {
			println("Recieved person: {p.firstName} {p.name}, {p.age}")	
		}
	}		
}

f(Person[name="renaud",firstName="pawlak",age=11])

f(Person[name="renaud",firstName="pawlak"])

f(Boy[age=2])

process p() {
	@consume(p) : [from=test_channel] {
		case {
			p of Person | !p.name || !p.firstName || !p.age {
				println("invalid person")
			} 
			p ~ Person[name,firstName,age] {
				println("Recieved person: {p.firstName} {p.name}, {p.age}")	
			}
			default {
				println("DEFAULT Recieved person: {p}")	
			}
		}
	}
}
*/

//p = Person[name="test"]

/*
declare channel +c0(Int)
declare channel +c1(Int)
declare channel +c2(Int)
declare predicate p1 "(<> end)"

process main() {
	@init() {
		p(c1, c2) : [node="n1"]
		p(c2, c0) : [node="n2"]
		println("processes started")
		c1.produce(1) : [checkpoint="start"]
	}
	c = @consume(v) : [channel=c0] {
		println("end of pipeline: {v}") : [checkpoint="end"]
		stop(c)
	}
}

process p(in, out) {
	c = @consume(v) : [channel=in] {
		println("{in}: {v}")
		out.produce(v+1)
		stop(c)
	}
}

*/