
import "ini/lib/mongo.ini"

declare type Document = [key1:String,name:String]

println("start test")
c = mongoClient("localhost:27017")
println("connected")
//c.mongoDatabase("test").mongoCollection("test").insertOne(mongoParse("{key1:\"value\"}"))
//println("wrote document")
it = c.mongoDatabase("test").mongoCollection("test").mongoFind()
println(it)
println("===>"+it.mongoFirst())

it.forEach(e => println(e))

println(Document[key1="hello",name="Renaud"])
println(mongoDocument(Document[key1="hello",name="Renaud"]))

c.mongoDatabase("test").mongoCollection("test").mongoInsertOne(Document[key1="hello",name="Renaud"])
c.close()

/*
type Child = Boy[age:Int]
	| Girl[age:Int]
type Person = [name:String,firstName:String,age:Int,children:Child*]
declare channel +test_channel(Person)

function f(p) {
	case {
		//p of Person | !p.name || !p.firstName || !p.age {
		//	println("invalid person")
		//}
		p ~ Person[name=="renaud",firstName,!age] {
			println("Recieved INVALID person: {p.firstName} {p.name}, {p.age}")	
		}
		p ~ Boy[] {
			println("child {p.age}")
		}
		p ~ Person[name,firstName,age] {
			println("Recieved person: {p.firstName} {p.name}, {p.age}")	
		}
	}		
}

f(Person[name="renaud",firstName="pawlak",age=11])

f(Person[name="renaud",firstName="pawlak"])

f(Boy[age=2])

process p() {
	@consume(p) : [from=test_channel] {
		case {
			p of Person | !p.name || !p.firstName || !p.age {
				println("invalid person")
			} 
			p ~ Person[name,firstName,age] {
				println("Recieved person: {p.firstName} {p.name}, {p.age}")	
			}
			default {
				println("DEFAULT Recieved person: {p}")	
			}
		}
	}
}
*/

//p = Person[name="test"]

/*
declare channel +c0(Int)
declare channel +c1(Int)
declare channel +c2(Int)
declare predicate p1 "(<> end)"

process main() {
	@init() {
		p(c1, c2) : [node="n1"]
		p(c2, c0) : [node="n2"]
		println("processes started")
		c1.produce(1) : [checkpoint="start"]
	}
	c = @consume(v) : [channel=c0] {
		println("end of pipeline: {v}") : [checkpoint="end"]
		stop(c)
	}
}

process p(in, out) {
	c = @consume(v) : [channel=in] {
		println("{in}: {v}")
		out.produce(v+1)
		stop(c)
	}
}

*/