
import "ini/lib/io.ini"
import "ini/lib/mongo.ini"

declare type Person = [firstName:String, lastName:String]

println(fetch(url("https://en.wikipedia.org/wiki/Jacques_Chirac")))

/*println("Connecting to Mongodb...")
client = mongoClient("localhost:27017")
println("Connected.")

collection = client.database("test").collection("test")
println("Writing to Mongodb...")
collection.insertOne(Person[key1="hello",name="Renaud"])
println("Wrote one document.")

println("Read and dump a collection:")
it = collection.find()
it.forEach(e => println(e))

it.toList().map(doc => fromDocument(Person[], doc)).foreach(e => {
	case e ~ Person[name] {
		println("valid person: "+e)
	}
})*/

//client.close()

/*
 * type Child = Boy[age:Int] | Girl[age:Int] type Person =
 * [name:String,firstName:String,age:Int,children:Child*] declare channel
 * +test_channel(Person)
 * 
 * function f(p) { case { //p of Person | !p.name || !p.firstName || !p.age { //
 * println("invalid person") //} p ~ Person[name=="renaud",firstName,!age] {
 * println("Recieved INVALID person: {p.firstName} {p.name}, {p.age}") } p ~
 * Boy[] { println("child {p.age}") } p ~ Person[name,firstName,age] {
 * println("Recieved person: {p.firstName} {p.name}, {p.age}") } } }
 * 
 * f(Person[name="renaud",firstName="pawlak",age=11])
 * 
 * f(Person[name="renaud",firstName="pawlak"])
 * 
 * f(Boy[age=2])
 * 
 * process p() { @consume(p) : [from=test_channel] { case { p of Person |
 * !p.name || !p.firstName || !p.age { println("invalid person") } p ~
 * Person[name,firstName,age] { println("Recieved person: {p.firstName}
 * {p.name}, {p.age}") } default { println("DEFAULT Recieved person: {p}") } } } }
 */

// p = Person[name="test"]

/*
 * declare channel +c0(Int) declare channel +c1(Int) declare channel +c2(Int)
 * declare predicate p1 "(<> end)"
 * 
 * process main() { @init() { p(c1, c2) : [node="n1"] p(c2, c0) : [node="n2"]
 * println("processes started") c1.produce(1) : [checkpoint="start"] } c =
 * @consume(v) : [channel=c0] { println("end of pipeline: {v}") :
 * [checkpoint="end"] stop(c) } }
 * 
 * process p(in, out) { c = @consume(v) : [channel=in] { println("{in}: {v}")
 * out.produce(v+1) stop(c) } }
 * 
 */