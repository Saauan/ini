

declare type Attr = [name:String,value:String]
declare type Xml = [name:String,text:String,id:Int,attr:Attr*,content:Xml*]

function main() {
	i=0
	xml = Xml[name = "html"]
	xml.content[0] = Xml[name = "head"]
	xml.content[1] = Xml[name = "body"]
	xml.content[1].attr[0] = Attr[name = "bgcolor", value = "white"]
	xml.content[1].attr[1] = Attr[name="width", value="100%"]
	xml.content[1].content[0] = Xml[text="this is a body text example "]
	b = Xml[name = "b"]
	xml.content[1].content[1] = b
	b.content[0] = Xml[text="this is a strong text"]
	pretty_print(xml)
	println(to_json(xml))
}

function pretty_print(xml,indent=0) {
	case xml ~ Xml[name,!text] {
		wait(print_tag(xml,indent))
	}
	case xml ~ Xml[!name,text] {
		println(xml.text)
	}
}

process print_tag(xml,indent) {
	@init() {
		wait(print_indent(indent))
		print("<"+xml.name)
		i = 0
		j = 0
	}
	i < size(xml.attr) {
		print(" "+xml.attr[i].name+"=\""+xml.attr[i].value+"\"")
		i++
	}
	i == size(xml.attr) {
		println(">")
		i++
	}
	i == size(xml.attr)+1 && j < size(xml.content) {
		pretty_print(xml.content[j++],indent+4)
	}
	@end() {
		wait(print_indent(indent))
		println("</"+xml.name+">")
	}
}

process print_indent(indent) {
	@init() {
		i=0
	}
	i < indent {
		print(" ")
		i++
	}
}
/*import "ini/lib/chanop.ini"
import "ini/lib/collect.ini"

s = "this is a text"

v = Global

println(v ~ Global?"tt":"vv")

c = channel()
s.foreach(letter => c.produce(letter))
result = c.mapc(letter => [letter, 1]).reduceByKey((a, b) => a + b)

c.stop()

println(result)
*/

//.consume(e => println(e))

//println(result)


/*import "ini/lib/chanop.ini"
import "ini/lib/collect.ini"

declare type Person = [name:String, age:Int]

l = [Person[name="Renaud",age=23],Person[name="Sacha",age=6], Person[name="Joris",age=23]]
	
c = channel().produceEach(l).stop()
result = channel().map(c, p => [p.age, [p.name]]).reduceByKey((a, b) => a & b)
//c.stop()
sleep(100)
println(result)
println(result)
println(result)
println(result)
println(result.to_json())*/

/*
 * println("Connecting to Mongodb...") client = mongoClient("localhost:27017")
 * println("Connected.")
 * 
 * collection = client.database("test").collection("test") println("Writing to
 * Mongodb...") collection.insertOne(Person[key1="hello",name="Renaud"])
 * println("Wrote one document.")
 * 
 * println("Read and dump a collection:") it = collection.find() it.forEach(e =>
 * println(e))
 * 
 * it.toList().map(doc => fromDocument(Person[], doc)).foreach(e => { case e ~
 * Person[name] { println("valid person: "+e) } })
 */

// client.close()

/*
 * type Child = Boy[age:Int] | Girl[age:Int] type Person =
 * [name:String,firstName:String,age:Int,children:Child*] declare channel
 * +test_channel(Person)
 * 
 * function f(p) { case { //p of Person | !p.name || !p.firstName || !p.age { //
 * println("invalid person") //} p ~ Person[name=="renaud",firstName,!age] {
 * println("Recieved INVALID person: {p.firstName} {p.name}, {p.age}") } p ~
 * Boy[] { println("child {p.age}") } p ~ Person[name,firstName,age] {
 * println("Recieved person: {p.firstName} {p.name}, {p.age}") } } }
 * 
 * f(Person[name="renaud",firstName="pawlak",age=11])
 * 
 * f(Person[name="renaud",firstName="pawlak"])
 * 
 * f(Boy[age=2])
 * 
 * process p() { @consume(p) : [from=test_channel] { case { p of Person |
 * !p.name || !p.firstName || !p.age { println("invalid person") } p ~
 * Person[name,firstName,age] { println("Recieved person: {p.firstName}
 * {p.name}, {p.age}") } default { println("DEFAULT Recieved person: {p}") } } } }
 */

// p = Person[name="test"]

/*
 * declare channel +c0(Int) declare channel +c1(Int) declare channel +c2(Int)
 * declare predicate p1 "(<> end)"
 * 
 * process main() { @init() { p(c1, c2) : [node="n1"] p(c2, c0) : [node="n2"]
 * println("processes started") c1.produce(1) : [checkpoint="start"] } c =
 * @consume(v) : [channel=c0] { println("end of pipeline: {v}") :
 * [checkpoint="end"] stop(c) } }
 * 
 * process p(in, out) { c = @consume(v) : [channel=in] { println("{in}: {v}")
 * out.produce(v+1) stop(c) } }
 * 
 */