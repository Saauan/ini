
import "ini/lib/math.ini"
import "ini/lib/collect.ini"

function consume(channel, handler, node="") {
	consumeProcess(channel, handler) : [node=node]
	return channel
}

function produceEach(channel, iterable) {
	iterable.foreach(e => channel.produce(e))
	return channel
}

function toChannel(iterable) {
	channel = channel()
	iterable.foreach(e => channel.produce(e))
	channel.stop()
	return channel
}

function merge(in1, in2) {
	out = channel()
	mergeProcess(out, in1, in2)
	return out
}

function duplicate(in, out1, out2, node="") {
	duplicateProcess(in, out1, out2) : [node=node]
	return in
}

function roundRobin(in, outs, node="") {
	roundRobinProcess(in, outs) : [node=node]
	return outs
}

function filter(out, in, predicate, node="") {
	filterProcess(out, in, predicate) : [node=node]
	return out
}

function combineLastest(out, in1, in2, combiner, node="") {
	combineLatestProcess(out, in1, in2, combiner) : [node=node]
	return out
}

function delay(in, time) {
	out = channel()
	delayProcess(out, time, in)
	return out
}

function distribute(in, startProcess, nodes=[]) {
	case nodes.size() == 0 {
		out = channel()
		startProcess(in, out, node())
	} else {
		hasRemote = false
		nodes.foreach(node => {
			case node != node() {
				hasRemote = true
			}
		})
		tmpIn = channel(hasRemote?Global:Local)
		bindProcess(in, tmpIn, 1, nodes.size())
		tmpOut = channel(hasRemote?Global:Local)
		nodes.foreach(node => {
			startProcess(tmpIn, tmpOut, node) : [node=node]
		})
		out = channel()
		bindProcess(tmpOut, out, nodes.size(), 1)
	}
	return out
}

function mapc(in, mapper, nodes=[]) {
    return distribute(in, (in, out, node) => {
		mapProcess(in, out, mapper) : [node=node]
	}, nodes)
}

function zip(out, in, tick, zipper=x=>x, node="") {
	zipProcess(out, in, tick, zipper) : [node=node]
	return out
}

function reduceByKey(in, reducer, node="") {
	return reduceByKeyProcess(in, reducer) : [node=node]
}

process consumeProcess(channel, handler) {
	@consume(value) : [channel = channel] {
		handler(value)
	}
}

process mergeProcess(out, in1, in2) {
	@consume(v) : [from=in1] {
		out.produce(v)
	}
	@consume(v) : [from=in2] {
		out.produce(v)
	}
	@end() {
		out.stop()
	}
}

process filterProcess(out, in, predicate) {
	@consume(v) : [from=in] && predicate() {
		out.produce(v)
	}
	@end() {
		out.stop()
	}
}

process delayProcess(out, time, in) {
	@consume(v) : [from=in] {
		sleep(time)
		out.produce(v)
	}
	@end() {
		out.stop()
	}
}

process combineLatestProcess(out, in1, in2, combiner) {
	@init() {
		latest1 = any()
		latest2 = any()
	}
	$(c2) c1 = @consume(v) : [from=in1] {
		latest1 = v
		case latest2 {
			out.produce(combiner(latest1, latest2))
		}
	}
	$(c1) c2 = @consume(v) : [from=in2] {
		latest2 = v
		case latest1 {
			out.produce(combiner(latest1, latest2))
		}
	}
	@end() {
		out.stop()
	}
}

process mapProcess(in, out, mapper) {
	@consume(v) : [from=in] {
		out.produce(mapper(v))
	}
	@end() {
		out.stop()
	}
}

process zipProcess(in, out, tick, zipper) {
	@init() {
		buffer = []
	}
	@consume() : [from=tick] {
		out.produce(zipper(buffer))
		buffer = []
	}
	@consume(v) : [from=in] {
		buffer = buffer & [v]
	}
}

process duplicateProcess(in, out1, out2) {
	@consume(v) : [from=in] {
		out1.produce(v)
		out2.produce(v)
	}
	@end() {
		out1.stop()
		out2.stop()
	}
}

process roundRobinProcess(in, outs) {
	@init() {
		i = 0
	}
	@consume(v) : [from=in] {
		outs[i].produce(v)
		i = mod(i + 1, outs.size())
	}
	@end() {
		outs.foreach(out => out.stop())
	}
}

process reduceByKeyProcess(in, reducer) {
	@init() {
		accumulator = []
	}
	@consume(v) : [from=in] {
	 	accumulator[v[0]] = reducer(accumulator[v[0]], v[1])
	}
	@end() {
		return accumulator
	}
}

function bind(in, out) {
	bindProcess(in, out)
	return out
}

process bindProcess(in, out, inProducerCount=1, outConsumerCount=1) {
	@consume(v) : [from=in, stop=inProducerCount] {
		out.produce(v)
	}
	@end() {
		[0..outConsumerCount].foreach(i => out.stop())
	}
}
