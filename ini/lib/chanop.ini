

function consume(channel, handler, node="") {
	consumeProcess(channel, handler) : [node=node]
	return channel
}

function merge(out, in1, in2, node="") {
	mergeProcess(out, in1, in2) : [node=node]
	return out
}

function fork(in, out1, out2, node="") {
	forkProcess(in, out1, out2) : [node=node]
	return [out1, out2]
}

function filter(out, in, predicate, node="") {
	filterProcess(out, in, predicate) : [node=node]
	return out
}

function combineLastest(out, in1, in2, combiner, node="") {
	combineLatestProcess(out, in1, in2, combiner) : [node=node]
	return out
}

function delay(out, time, in, node="") {
	delayProcess(out, time, in) : [node=node]
	return out
}

function map(out, in, mapper, node="") {
	mapProcess(out, in, mapper) : [node=node]
	return out
}

function zip(out, in, tick, zipper=x=>x, node="") {
	zipProcess(out, in, tick, zipper) : [node=node]
	return out
}

process consumeProcess(channel, handler) {
	@consume(value) : [channel = channel] {
		handler(value)
	}
}

process mergeProcess(out, in1, in2) {
	@consume(v) : [from=in1] {
		out.produce(v)
	}
	@consume(v) : [from=in2] {
		out.produce(v)
	}
	@end() {
		out.stop()
	}
}

process filterProcess(out, in, predicate) {
	@consume(v) : [from=in] && predicate() {
		out.produce(v)
	}
	@end() {
		out.stop()
	}
}

process delayProcess(out, time, in) {
	@consume(v) : [from=in] {
		sleep(time)
		out.produce(v)
	}
	@end() {
		out.stop()
	}
}

process combineLatestProcess(out, in1, in2, combiner) {
	@init() {
		latest1 = any()
		latest2 = any()
	}
	$(c2) c1 = @consume(v) : [from=in1] {
		latest1 = v
		case latest2 {
			out.produce(combiner(latest1, latest2))
		}
	}
	$(c1) c2 = @consume(v) : [from=in2] {
		latest2 = v
		case latest1 {
			out.produce(combiner(latest1, latest2))
		}
	}
	@end() {
		out.stop()
	}
}

process mapProcess(out, in, mapper) {
	@consume(v) : [from=in] {
		out.produce(mapper(v))
	}
	@end() {
		out.stop()
	}
}

process forkProcess(in, out1, out2) {
	@consume(v) : [from=in] {
		out1.produce(v)
		out2.produce(v)
	}
	@end() {
		out1.stop()
		out2.stop()
	}
}

process zipProcess(out, in, tick, zipper) {
	@init() {
		buffer = []
	}
	@consume() : [from=tick] {
		out.produce(zipper(buffer))
		buffer = []
	}
	@consume(v) : [from=in] {
		buffer = buffer & [v]
	}
}
