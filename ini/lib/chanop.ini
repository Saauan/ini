
import "ini/lib/math.ini"
import "ini/lib/collect.ini"

function consume(channel, handler, node="") {
	consumeProcess(channel, handler) : [node=node]
	return channel
}

function produceEach(channel, iterable) {
	iterable.foreach(e => channel.produce(e))
	return channel
}

function merge(in1, in2) {
	out = channel()
	mergeProcess(out, in1, in2)
	return out
}

function duplicate(in, out1, out2, node="") {
	duplicateProcess(in, out1, out2) : [node=node]
	return in
}

function roundRobin(in, outs, node="") {
	roundRobinProcess(in, outs) : [node=node]
	return outs
}

function filter(out, in, predicate, node="") {
	filterProcess(out, in, predicate) : [node=node]
	return out
}

function combineLastest(out, in1, in2, combiner, node="") {
	combineLatestProcess(out, in1, in2, combiner) : [node=node]
	return out
}

function delay(in, time) {
	out = channel()
	delayProcess(out, time, in)
	return out
}

function mapc(in, mapper, nodes=[]) {
	case nodes.size() == 0 {
		out = channel()
		mapProcess(out, in, mapper)
	} else {
		chans = []
		hasRemote = false
		nodes.foreach(node => {
			chans = chans & [channel(node != node())]
			case node != node() {
				hasRemote = true
			}
		})
		in.roundRobinProcess(chans)
		out = channel(hasRemote)
		[0..nodes.size()-1].foreach(i => {
			mapProcess(out, chans[i], mapper) : [node=nodes[i]]
		})
	}
	return out
}

function zip(out, in, tick, zipper=x=>x, node="") {
	zipProcess(out, in, tick, zipper) : [node=node]
	return out
}

function reduceByKey(in, reducer, node="") {
	return reduceByKeyProcess(in, reducer) : [node=node]
}

process consumeProcess(channel, handler) {
	@consume(value) : [channel = channel] {
		handler(value)
	}
}

process mergeProcess(out, in1, in2) {
	@consume(v) : [from=in1] {
		out.produce(v)
	}
	@consume(v) : [from=in2] {
		out.produce(v)
	}
	@end() {
		out.stop()
	}
}

process filterProcess(out, in, predicate) {
	@consume(v) : [from=in] && predicate() {
		out.produce(v)
	}
	@end() {
		out.stop()
	}
}

process delayProcess(out, time, in) {
	@consume(v) : [from=in] {
		sleep(time)
		out.produce(v)
	}
	@end() {
		out.stop()
	}
}

process combineLatestProcess(out, in1, in2, combiner) {
	@init() {
		latest1 = any()
		latest2 = any()
	}
	$(c2) c1 = @consume(v) : [from=in1] {
		latest1 = v
		case latest2 {
			out.produce(combiner(latest1, latest2))
		}
	}
	$(c1) c2 = @consume(v) : [from=in2] {
		latest2 = v
		case latest1 {
			out.produce(combiner(latest1, latest2))
		}
	}
	@end() {
		out.stop()
	}
}

process mapProcess(out, in, mapper) {
	@consume(v) : [from=in] {
		out.produce(mapper(v))
	}
	@end() {
		out.stop()
	}
}

process zipProcess(out, in, tick, zipper) {
	@init() {
		buffer = []
	}
	@consume() : [from=tick] {
		out.produce(zipper(buffer))
		buffer = []
	}
	@consume(v) : [from=in] {
		buffer = buffer & [v]
	}
}

process duplicateProcess(in, out1, out2) {
	@consume(v) : [from=in] {
		out1.produce(v)
		out2.produce(v)
	}
	@end() {
		out1.stop()
		out2.stop()
	}
}

process roundRobinProcess(in, outs) {
	@init() {
		i = 0
	}
	$(c) c=@consume(v) : [from=in] {
		outs[i].produce(v)
		i = mod(i + 1, outs.size())
	}
	@end() {
		outs.foreach(out => out.stop())
	}
}

process reduceByKeyProcess(in, reducer) {
	@init() {
		accumulator = []
	}
	@consume(v) : [from=in] {
		accumulator[v[0]] = reducer(accumulator[v[0]], v[1])
	}
	@end() {
		return accumulator
	}
}
