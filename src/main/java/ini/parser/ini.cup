
/*
 * This source code file is the exclusive property of its author. No copy or 
 * usage of the source code is permitted unless the author contractually 
 * allows it under the terms of a well-defined agreement.
 */

import java.util.*;
import java.io.*;
import ini.*;
import ini.ast.*;
import ini.ast.Process;
import ini.eval.function.*;
import ini.eval.at.*;

parser code {:

	public Types types;
	public PrintStream out = System.out;
	public PrintStream err = System.err;
	private int userTypeIndex = 1;

	public int nextUserTypeIndex() {
		return userTypeIndex++;
	}

	//public Map<String,Executable> parsedFunctionMap=new HashMap<String,Executable>();
	//public List<Executable> parsedFunctionList=new ArrayList<Executable>();
	//public List<Binding> parsedBindingList=new ArrayList<Binding>();
	//public List<AtBinding> parsedAtBindingList=new ArrayList<AtBinding>();
	//public List<Import> parsedImportList=new ArrayList<Import>();
	//public List<AstNode> parsedAst =  new ArrayList<AstNode>();
	public List<AstNode> topLevels =  new ArrayList<AstNode>();

	public IniEnv env;
	public List<Executable> builtInExecutables;

	private List<Executable> createBuiltInExecutables() {
		return Arrays.asList( //
			new ClearFunction(this), //
			new CopyFunction(this), //
			new ErrorFunction(this), //
			new FirstFunction(this), //
			new KeyFunction(this), //
			new KillAt(this), //
			new PrintFunction(this), //
			new PrintlnFunction(this), //
			new ProduceFunction(this), //
			new ReadKeyboardFunction(this), //
			new RestFunction(this), //
			new SizeFunction(this), //
			new SleepFunction(this), //
			new SwapFunction(this), //
			new TimeFunction(this), //
			new ToIntFunction(this), //
			new ToJsonFunction(this), //
			new ToLongFunction(this), //
			new ToByteFunction(this), //
			new ToCharFunction(this), //
			new ToFloatFunction(this), //
			new ToDoubleFunction(this), //
			new ToStringFunction(this), //
			new WaitFunction(this), //
			// ========================
			// will be removed from default builtins and accessed through bindings
			new StartWebServiceFunction(this), //
			new StopWebServiceFunction(this)
		);
	}
	
	public static IniParser createParserForFile(IniEnv env, IniParser parent, String fileName) throws java.io.FileNotFoundException {
      IniScanner scanner= new IniScanner(new java.io.FileReader(fileName));
      scanner.setFileName(fileName);
      IniParser parser= new IniParser(scanner);
      if(env==null) {
      	env = new IniEnv();
      }
      parser.env = env;
      if(parent != null) {
	      parser.types = parent.types;
	      parser.builtInExecutables = parser.builtInExecutables;
	  } else {
	      parser.types = new Types(parser);
	      parser.builtInExecutables = parser.createBuiltInExecutables();
	  }
      return parser;
	}

	public static IniParser createParserForCode(IniEnv env, IniParser parent, String code) throws Exception {
      IniScanner scanner= new IniScanner(new java.io.StringReader(code));
      scanner.setFileName("<none>");
      IniParser parser= new IniParser(scanner);
      if(env==null) {
      	env = new IniEnv();
      }
      parser.env = env;
      if(parent != null) {
	      parser.types = parent.types;
	      parser.builtInExecutables = parser.builtInExecutables;
	  } else {
	      parser.types = new Types(parser);
	      parser.builtInExecutables = parser.createBuiltInExecutables();
	  }
      return parser;
	}

	public List<SyntaxError> errors = new ArrayList<SyntaxError>();
	
  public void syntax_error(java_cup.runtime.Symbol current) {
    //errors.add(new SyntaxError("syntax error: '"+current.value + "' is not expected", at " + (current.left+1)+"("+(current.right+1)+")" );
    errors.add(new SyntaxError((Token)current.value, "'"+current.value + "' is not expected"));
  }
  
  	public void printErrors(PrintStream out) {
		for (SyntaxError error : errors) {
			out.println(error.toString());
		}
	}

	public boolean hasErrors() {
		return !errors.isEmpty();
	}
  
  
  
:};

terminal COL, COMMA, DOT, INVDOT, DOTDOT;
terminal LPAREN, RPAREN, LCPAREN, RCPAREN, LSPAREN, RSPAREN;
terminal LT, LTE, GTE, GT, ASSIGN, EQUALS, NOTEQUALS, MULT, DIV, MINUS, MINUSMINUS, PLUS, PLUSPLUS;
terminal OROR, ANDAND, AND, NOT, TUBE, IMPLIES, MATCHES;
terminal AT, ARROW_RIGHT;
terminal INT, NUM, TRUE, FALSE, STRING, CHAR;
terminal IDENTIFIER, TIDENTIFIER;
terminal QUESTION, DOLLAR;
terminal LF, END;
// keywords
terminal IMPORT, FUNCTION, PROCESS, LAMBDA, OF, RETURN, TYPE, THIS, CASE, DEFAULT, ELSE, DECLARE;

non terminal lf, lf_opt;
non terminal ini_program, program_elt_list_opt, program_elt_list, program_elt; 
non terminal function, param_list_opt, param_list, param;
non terminal import_decl;
non terminal binding, type_list_opt, type_list, type, type_decl_list_opt, type_decl_list, type_decl, at_binding_conf_type;
non terminal var_list;
non terminal statement_list_opt, statement_list, top_level_statement, statement, expr, no_paren_expr;
non terminal assignment_expr, var_access, sync_var_access, set_var_access, single_string, string_expr, case_expr, lambda_expr;
non terminal ret_statement;
non terminal invocation, dot_invocation, pre_post_op, arg_list_opt, arg_list, list_expr;
non terminal rule_list_opt, rule_list, rule, guard;
non terminal logical_expr_opt, logical_expr, algebraic_expr, set_logical_expr, boolean_literal;
non terminal set_decl, constructor_expr, assignment_list;
non terminal at_expr, at_binding, annotations_opt;
non terminal usertype, constructor_list, constructor, list_constructor, constructor_or_type;
non terminal field_list_opt, field_list, field;
non terminal constructor_match_expr;
non terminal field_match_expr_list_opt, field_match_expr_list;
non terminal list_concat_expr;

precedence left DOLLAR;
precedence left ASSIGN;
precedence left OROR;
precedence left ANDAND;
precedence left MATCHES;
precedence left NOT;
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left PLUSPLUS, MINUSMINUS;
precedence left EQUALS, GT, GTE, LT, LTE, NOTEQUALS;
precedence left TUBE;
precedence left LF;
precedence left END;
precedence left IMPLIES;
precedence left DOT, INVDOT;

start with ini_program;

/***************************************************************/
/***                      INI GRAMMAR                         **/    
/***************************************************************/

lf ::= lf LF | LF;

lf_opt ::= lf |;

ini_program ::= lf_opt program_elt_list_opt;

program_elt_list_opt ::= program_elt_list lf_opt |;

program_elt_list ::= program_elt_list lf program_elt:e  {: parser.topLevels.add((AstNode)e); :} 
	| program_elt:e {: parser.topLevels.add((AstNode)e); :};

program_elt ::= import_decl:e {: RESULT=e; :} 
	| binding:e {: RESULT=e; :} 
	| at_binding:e {: RESULT=e; :} 
	| function:e {: RESULT=e; :} 
	| usertype:e {: RESULT=e; :} 
	| top_level_statement:e {: RESULT=e; :};

import_decl ::= IMPORT:itoken STRING:filePath
	{:
		Import i = new Import(parser, (Token)itoken, filePath.toString());
		try {
			IniParser localParser = IniParser.createParserForFile(parser.env, parser, filePath.toString());
			localParser.parse();
			i.importParser = localParser;
			//parser.parsedFunctionMap.putAll(localParser.parsedFunctionMap);
			//parser.parsedBindingList.addAll(localParser.parsedBindingList);
			//parser.parsedFunctionList.addAll(localParser.parsedFunctionList);
		} catch (java.io.FileNotFoundException e) {
			throw new RuntimeException("Cannot import file '" + i.filePath + "'" 
				+ (i.token != null ? " at " + i.token.getLocation() : ""));
		}
		//parser.parsedImportList.add(i);
		RESULT = i;
	:}
;

binding ::= DECLARE:d IDENTIFIER:name LPAREN:ft type_list_opt:types RPAREN IMPLIES type:rtype annotations_opt:a
	{:
		Binding b = new Binding(parser, (Token)d, name.toString(), (List)null, (List)types, (TypeVariable)rtype, (List)a);
		//parser.parsedBindingList.add(b);
		RESULT = b;
	:} 
	| DECLARE:d LPAREN type_decl_list_opt:typedecls RPAREN IDENTIFIER:name LPAREN:ft type_list_opt:types RPAREN IMPLIES type:rtype annotations_opt:a
	{:
		Binding b = new Binding(parser, (Token)d, name.toString(), (List)typedecls, (List)types, (TypeVariable)rtype, (List)a);
		RESULT = b;
	:}
	| DECLARE:d type_decl_list_opt:typedecls
	{:
		Binding b = new Binding(parser, (Token)d, (String)null, (List)typedecls, (List)null, (TypeVariable)null, (List)null);
		RESULT = b;
	:}
;

at_binding_conf_type ::=
| LSPAREN type_list_opt:ct RSPAREN
{:
	RESULT = ct;
:}
;

at_binding ::= DECLARE:d AT IDENTIFIER:name at_binding_conf_type:ct LPAREN:ft type_list_opt:rt RPAREN IMPLIES STRING:className
	{:
		AtBinding b = new AtBinding(parser, (Token)d, name.toString(), (List)ct, (List) rt, className.toString());
		//parser.parsedAtBindingList.add(b);
		RESULT = b;
	:}
;

function ::= FUNCTION:def IDENTIFIER:name LPAREN param_list_opt:vars RPAREN LCPAREN statement_list_opt:statements RCPAREN
	{:
		//System.out.println("created function "+name);
		Function f = new Function(parser, (Token)def, name.toString(), (List)vars, (Sequence)statements);
		//parser.parsedFunctionMap.put(f.name,f);
		//parser.parsedFunctionList.add(f);
		//f.prettyPrint(System.out);
		RESULT = f;
	:} 
	| PROCESS:def IDENTIFIER:name LPAREN param_list_opt:vars RPAREN LCPAREN rule_list_opt:rules RCPAREN
	{:
		//System.out.println("created process "+name);
		Process p = new Process(parser, (Token)def, name.toString(), (List)vars, (List)rules);
		//parser.parsedFunctionMap.put(p.name,p);
		//parser.parsedFunctionList.add(p);
		//p.prettyPrint(System.out);
		RESULT = p;
	:} 
;

param_list_opt ::= param_list:l {: RESULT = l; :}
	| {: RESULT = new ArrayList(); :}
;

param_list ::= param_list:l COMMA param:p
	{:
		List list=(List)l;
		list.add(p);
		RESULT=list;
	:}
		| param:p
	{:
		List l=new ArrayList();
		l.add(p);
		RESULT=l;
	:}
;

param ::= IDENTIFIER:i ASSIGN:a expr:e 
	{:
		RESULT = new Parameter(parser,(Token)i,i.toString(),(Expression)e);
	:}
	| IDENTIFIER:i 
	{:
		RESULT = new Parameter(parser,(Token)i,i.toString());
	:}
;

statement_list_opt ::= lf_opt statement_list:l lf_opt {: RESULT=l; :}
	| lf_opt
;

statement_list ::= statement_list:l lf statement:s
	{:
		Sequence seq=(Sequence)l;
		seq.last().setNext(s);
		RESULT = seq;
	:}
	| statement:s
	{:
		Sequence seq=new Sequence(s);
		RESULT=seq;
	:}
;

rule_list_opt ::= lf_opt rule_list:rl lf_opt {: RESULT=rl; :}
	| lf_opt {: RESULT=new ArrayList(); :} 
;

rule_list ::= rule_list:l lf rule:r
	{:
		List list=(List)l;
		list.add(r);
		RESULT = list;
	:}
	| rule:r
	{:
		List l=new ArrayList();
		l.add(r);
		RESULT=l;
	:}
;

var_list ::= var_list:l COMMA IDENTIFIER:i
	{:
		List list=(List)l;
		list.add(new Variable(parser,(Token)i,i.toString()));
		RESULT=list;
	:}
		| IDENTIFIER:i
	{:
		List l=new ArrayList();
		l.add(new Variable(parser,(Token)i,i.toString()));
		RESULT=l;
	:}
;

type_list_opt ::= type_list:l {: RESULT = l; :} | ;

type_list ::= type_list:l COMMA type:t
	{:
		List list=(List)l;
		list.add(t);
		RESULT=list;
	:}
		| type:t
	{:
		List l=new ArrayList();
		l.add(t);
		RESULT=l;
	:}
;

type ::= TIDENTIFIER:i {: RESULT = new TypeVariable(parser,(Token)i,i.toString()); :}
	| type:t MULT {: RESULT = new TypeVariable(parser,((TypeVariable)t).token,(TypeVariable)t); :}
;

type_decl_list_opt ::= type_decl_list:l {: RESULT = l; :} | ;

type_decl_list ::= type_decl_list:l COMMA type_decl:t
	{:
		List list=(List)l;
		list.add(t);
		RESULT=list;
	:}
		| type_decl:t
	{:
		List l=new ArrayList();
		l.add(t);
		RESULT=l;
	:}
;

type_decl ::= TIDENTIFIER:i {: RESULT = new TypeVariable(parser,(Token)i,i.toString(), true); :}
	| TIDENTIFIER:i LT TIDENTIFIER:s {: 
		TypeVariable tv = new TypeVariable(parser,(Token)i,i.toString(), true);
		TypeVariable sv = new TypeVariable(parser,(Token)s,s.toString());
		tv.superType = sv;
		RESULT = tv;
	:}
;


assignment_expr ::= var_access:v ASSIGN:a expr:e
	{:
		RESULT = new Assignment(parser,(Token)a,(VariableAccess)v,(Expression)e);
	:}
	| var_access:v ASSIGN:a boolean_literal:e 
	{: 
		RESULT = new Assignment(parser,(Token)a,(VariableAccess)v,(Expression)e);
	:}
	| set_var_access:v ASSIGN:a set_decl:e 
	{: 
		RESULT = new Assignment(parser,(Token)a,(VariableAccess)v,(Expression)e);
	:}
;

set_var_access ::= TIDENTIFIER:v {: RESULT = new Variable(parser,(Token)v,v.toString()); :}
;

boolean_literal ::= TRUE:e {: RESULT=new BooleanLiteral(parser,(Token)e,true); :}
	| FALSE:e {: RESULT=new BooleanLiteral(parser,(Token)e,false); :}
;

var_access ::= IDENTIFIER:v {: RESULT = new Variable(parser,(Token)v,v.toString()); :}
	| var_access:v LSPAREN:t expr:e RSPAREN {: RESULT = new ArrayAccess(parser,(Token)t,(VariableAccess)v,(Expression)e); :}
	| var_access:v LSPAREN:t expr:min DOTDOT expr:max RSPAREN {: RESULT = new SubArrayAccess(parser,(Token)t,(VariableAccess)v,(Expression)min,(Expression)max); :}
	| var_access:v DOT:t IDENTIFIER:i {: RESULT = new FieldAccess(parser,(Token)t,(VariableAccess)v,i.toString()); :}
;

string_expr ::= single_string:s {: RESULT=s; :}
	| single_string:e1 PLUS:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.PLUS,(Expression)e1,(Expression)e2); :}
;

single_string ::= STRING:s {: RESULT=new StringLiteral(parser,(Token)s,s.toString()); :}
;

list_expr ::= LSPAREN:open arg_list_opt:l RSPAREN:close
	{:
		RESULT = new ListExpression(parser,(Token)open,(List)l);
	:}
;

constructor_expr ::= TIDENTIFIER:s LSPAREN lf_opt assignment_list:l lf_opt RSPAREN
	{:
		RESULT = new SetConstructor(parser,(Token)s,s.toString(),(List)l);
	:}/*
	| LSPAREN:c assignment_list:l RSPAREN
	{:
		RESULT = new SetConstructor(parser,(Token)c,null,(List)l);
	:}*/
;

constructor_match_expr ::= TIDENTIFIER:s LSPAREN field_match_expr_list_opt:l RSPAREN 
	{:
		RESULT = new ConstructorMatchExpression(parser,(Token)s,s.toString(),(List)l);	
	:} | TIDENTIFIER:s 
	{:
		RESULT = new ConstructorMatchExpression(parser,(Token)s,s.toString(),null);	
	:};

assignment_list ::= assignment_list:l COMMA lf_opt IDENTIFIER:f ASSIGN:a expr:e 
	{:
		List list=(List)l;
		list.add(new Assignment(parser,(Token)f,new Variable(parser,(Token)f,f.toString()),(Expression)e));
		RESULT=list;
	:}
		| IDENTIFIER:f ASSIGN:a expr:e
	{:
		List list=new ArrayList();
		list.add(new Assignment(parser,(Token)f,new Variable(parser,(Token)f,f.toString()),(Expression)e));
		RESULT=list;
	:}
;

top_level_statement ::= pre_post_op:e {: RESULT = e; :}
	| assignment_expr:e {: RESULT = e; :} 
	| invocation:e {: RESULT = e; :}
	| dot_invocation:e {: RESULT = e; :}
	| case_expr:e {: RESULT = e; :}
;

statement ::= pre_post_op:e {: RESULT = e; :}
	| assignment_expr:e {: RESULT = e; :} 
	| invocation:e {: RESULT = e; :}
	| dot_invocation:e {: RESULT = e; :}
	| case_expr:e {: RESULT = e; :}
	| ret_statement:e {: RESULT = e; :}
;

no_paren_expr ::= var_access:e {: RESULT=e; :}
    | THIS:t {: RESULT = new ThisLiteral(parser,(Token)t); :}
	| invocation:e {: RESULT=e; :}
	| dot_invocation:e {: RESULT=e; :}
	| CHAR:c {: RESULT = new CharLiteral(parser,(Token)c,c.toString().charAt(0)); :}
	| list_expr:l {: RESULT=l; :}
;

expr ::= var_access:e {: RESULT=e; :}
	| var_access:v ASSIGN:a expr:e 
	{:
		RESULT = new Assignment(parser,(Token)a,(VariableAccess)v,(Expression)e);
	:}
	| sync_var_access:e {: RESULT=e; :} 
    | THIS:t {: RESULT = new ThisLiteral(parser,(Token)t); :}
	| invocation:e {: RESULT=e; :}
	| dot_invocation:e {: RESULT=e; :}
	| CHAR:c {: RESULT = new CharLiteral(parser,(Token)c,c.toString().charAt(0)); :}
	| algebraic_expr:e {: RESULT=e; :}
	| string_expr:e {: RESULT=e; :}
	| list_expr:l {: RESULT=l; :}
	| constructor_expr: e {: RESULT=e; :}
	| set_decl:e {: RESULT = e; :}
	| set_var_access:e {: RESULT = e; :}
//	| FUNCTION:f LPAREN IDENTIFIER:i RPAREN {: RESULT = new FunctionLiteral(parser,(Token)f,i.toString()); :}
	| list_concat_expr:e {: RESULT = e; :}
	| lambda_expr: e {: RESULT = e; :}
;

// TODO: the LAMBDA symbol is produced by the lexer with a look-ahead. The parser should disambiguate itself for better perfs.
lambda_expr ::= LAMBDA LPAREN param_list_opt:vars RPAREN IMPLIES:def LCPAREN statement_list_opt:statements RCPAREN {:
	RESULT = new Function(parser, (Token)def, null, (List)vars, (Sequence)statements);	
:} | LAMBDA param_list_opt:vars IMPLIES:def LCPAREN statement_list_opt:statements RCPAREN {:
	RESULT = new Function(parser, (Token)def, null, (List)vars, (Sequence)statements);	
:} | LAMBDA LPAREN param_list_opt:vars RPAREN IMPLIES:def expr:s {:
	RESULT = new Function(parser, (Token)def, null, (List)vars, new Sequence(s));
:} | LAMBDA param_list_opt:vars IMPLIES:def expr:s {:
	RESULT = new Function(parser, (Token)def, null, (List)vars, new Sequence(s));	
:}
;

/*list_concat_expr ::= list_concat_expr:e1 AND:op var_access:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.CONCAT,(Expression)e1,(Expression)e2); :}
	| list_concat_expr:e1 AND:op invocation:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.CONCAT,(Expression)e1,(Expression)e2); :}
	| list_expr:e1 AND:op list_concat_expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.CONCAT,(Expression)e1,(Expression)e2); :}
;*/	


list_concat_expr ::= no_paren_expr:e1 AND:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.CONCAT,(Expression)e1,(Expression)e2); :}
//	| var_access:e1 AND:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.CONCAT,(Expression)e1,(Expression)e2); :}
;

algebraic_expr ::= NUM:e {: RESULT=new NumberLiteral(parser,(Token)e,Double.parseDouble(e.toString())); :}
	| INT:e {: RESULT=new NumberLiteral(parser,(Token)e,Integer.parseInt(e.toString())); :} 
	| pre_post_op:op {: RESULT=op; :}
	| expr:e1 PLUS:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.PLUS,(Expression)e1,(Expression)e2); :}
	| expr:e1 MINUS:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.MINUS,(Expression)e1,(Expression)e2); :}
	| MINUS:op expr:e {: RESULT=new UnaryOperator(parser,(Token)op,UnaryOperator.Kind.MINUS,(Expression)e); :}
	| expr:e1 MULT:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.MULT,(Expression)e1,(Expression)e2); :}
	| expr:e1 DIV:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.DIV,(Expression)e1,(Expression)e2); :}
	| LPAREN algebraic_expr:e RPAREN {: RESULT=e; :}
;

logical_expr ::= boolean_literal:e {: RESULT=e; :}
	| var_access:e {: RESULT=e; :} 
	| var_access:v ASSIGN:a logical_expr:e 
	{:
		RESULT = new Assignment(parser,(Token)a,(VariableAccess)v,(Expression)e);
	:}
	| sync_var_access:e {: RESULT=e; :} 
	| invocation:e {: RESULT=e; :}
	| logical_expr:e1 ANDAND:op logical_expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.AND,(Expression)e1,(Expression)e2); :}
	| logical_expr:e1 OROR:op logical_expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.OR,(Expression)e1,(Expression)e2); :}
	| NOT:op logical_expr:e {: RESULT=new UnaryOperator(parser,(Token)op,UnaryOperator.Kind.NOT,(Expression)e); :}
	| QUESTION:op logical_expr:e {: RESULT=new UnaryOperator(parser,(Token)op,UnaryOperator.Kind.OPT,(Expression)e); :}
	| expr:e1 EQUALS:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.EQUALS,(Expression)e1,(Expression)e2); :}
	| expr:e1 NOTEQUALS:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.NOTEQUALS,(Expression)e1,(Expression)e2); :}
	| expr:e1 LT:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.LT,(Expression)e1,(Expression)e2); :}
	| expr:e1 LTE:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.LTE,(Expression)e1,(Expression)e2); :}
	| expr:e1 GT:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.GT,(Expression)e1,(Expression)e2); :}
	| expr:e1 GTE:op expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.GTE,(Expression)e1,(Expression)e2); :}
	| expr:e1 MATCHES:op invocation:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.MATCHES,(Expression)e1,(Expression)e2); :}
	| expr:e1 MATCHES:op constructor_match_expr:e2 {: RESULT=new BinaryOperator(parser,(Token)op,BinaryOperator.Kind.MATCHES,(Expression)e1,(ConstructorMatchExpression)e2); :}
	| LPAREN logical_expr:e RPAREN {: RESULT=e; :}
;

case_expr ::= CASE:c LCPAREN rule_list_opt:l DEFAULT LCPAREN statement_list_opt:s RCPAREN RCPAREN 
	{:
		RESULT = new CaseStatement(parser,(Token)c, (List)l,(Sequence)s); 
	:}
	| CASE:c LCPAREN rule_list_opt:l RCPAREN 
	{:
		RESULT = new CaseStatement(parser,(Token)c, (List)l,null); 
	:}
	| CASE:c rule:r 
	{:
		RESULT = new CaseStatement(parser,(Token)c,(List<Rule>)(List)Arrays.asList(r),null); 
	:}
	| CASE:c rule:r ELSE LCPAREN statement_list_opt:s RCPAREN
	{:
		RESULT = new CaseStatement(parser,(Token)c,(List<Rule>)(List)Arrays.asList(r),(Sequence)s); 
	:}
;

field_match_expr_list_opt ::= field_match_expr_list:l {: RESULT = l; :} 
	| {: RESULT = new ArrayList(); :};

field_match_expr_list ::= field_match_expr_list:l COMMA logical_expr:f
	{:
		List list=(List)l;
		list.add(f);
		RESULT=list;
	:}
		| logical_expr:f
	{:
		List l=new ArrayList();
		l.add(f);
		RESULT=l;
	:}
;

annotations_opt ::= LSPAREN arg_list:l RSPAREN
{:
	RESULT = (List)l;
:}
|
{:
	RESULT = (List)null;
:}
;

at_expr ::= IDENTIFIER:id COL AT:at IDENTIFIER:name LPAREN arg_list_opt:rp RPAREN annotations_opt:a
{: 
	RESULT = new AtPredicate(parser,(Token)at,name.toString(),(List)a,(List)rp, id.toString());
:}
| AT:at IDENTIFIER:name LPAREN arg_list_opt:rp RPAREN annotations_opt:a
{: 
	RESULT = new AtPredicate(parser,(Token)at,name.toString(),(List)a,(List)rp, null);
:}
;

pre_post_op ::= var_access:e PLUSPLUS:op {: RESULT=new UnaryOperator(parser,(Token)op,UnaryOperator.Kind.POST_INC,(Expression)e); :}
	| var_access:e MINUSMINUS:op {: RESULT=new UnaryOperator(parser,(Token)op,UnaryOperator.Kind.POST_DEC,(Expression)e); :}
;

invocation ::= IDENTIFIER:i LPAREN arg_list_opt:l RPAREN annotations_opt:a
	{:
		Invocation inv = new Invocation(parser,(Token)i,i.toString(),(List)l);
		inv.annotations = (List)a;
		RESULT = inv;
	:}
;

dot_invocation ::= no_paren_expr:target INVDOT IDENTIFIER:i LPAREN arg_list_opt:l RPAREN annotations_opt:a
	{:
		List args = (List)l;
		args.add(0, target);
		Invocation inv = new Invocation(parser,(Token)i,i.toString(),args);
		inv.annotations = (List)a;
		RESULT = inv;
	:}
;

arg_list_opt ::= arg_list:l {: RESULT=l; :} | {: RESULT=new ArrayList(); :}
;

arg_list ::= arg_list:l COMMA expr:e
	{:
		List list=(List)l;
		list.add(e);
		RESULT=list;
	:}
	| expr:e
	{:
		List list=new ArrayList();
		list.add(e);
		RESULT=list;
	:}
;

rule ::= at_expr:at logical_expr_opt:g LCPAREN statement_list_opt:l RCPAREN
	{:
		RESULT = new Rule(parser,((AstNode)at).token(),(AtPredicate)at,(Expression)g,(Sequence)l, null);
	:}
	| DOLLAR LPAREN arg_list_opt:el RPAREN at_expr:at logical_expr_opt:g LCPAREN statement_list_opt:l RCPAREN
	{:
		RESULT = new Rule(parser,((AstNode)at).token(),(AtPredicate)at,(Expression)g,(Sequence)l, (List)el);
	:}
	| guard:g LCPAREN statement_list_opt:l RCPAREN
	{:
		RESULT = new Rule(parser,((AstNode)g).token(),null,(Expression)g,(Sequence)l, null);
	:}
;

logical_expr_opt ::= ANDAND logical_expr:e {: RESULT = e; :} | ;

ret_statement ::= RETURN:r expr:e {: RESULT = new ReturnStatement(parser,(Token)r,(Expression)e); :}
	| RETURN:r boolean_literal:e {: RESULT = new ReturnStatement(parser,(Token)r,(Expression)e); :}
	| RETURN:r {: RESULT = new ReturnStatement(parser,(Token)r,null); :}
;

guard ::= logical_expr:e {: RESULT=e; :}
	| set_logical_expr:e {: RESULT=e; :}
;

set_logical_expr ::= var_list:l OF:of set_decl:s TUBE logical_expr:e
	{:
		RESULT = new SetExpression(parser,(Token)of,(List)l,(Expression)s,(Expression)e);
	:}
	| var_list:l OF:of set_var_access:s TUBE logical_expr:e
	{:
		RESULT = new SetExpression(parser,(Token)of,(List)l,(Expression)s,(Expression)e);
	:}	
;

set_decl ::= LSPAREN:l expr:lb DOTDOT expr:ub RSPAREN:r {:
	RESULT = new SetDeclaration(parser,(Token)l,(Expression)lb,(Expression)ub);
:}
;

usertype ::= TYPE:t TIDENTIFIER:i ASSIGN constructor_list:l lf_opt END
	{:
		UserType type = new UserType(parser,(Token)t,i.toString(),(List)l);
		// parser.parsedTypes.add(type);
		RESULT = type;
	:}
;

constructor_list ::= constructor_list:l lf_opt TUBE constructor:c
	{:
		List list=(List)l;
		list.add(c);
		RESULT=list;
	:}
	| constructor:c
	{:
		List list=new ArrayList();
		list.add(c);
		RESULT=list;
	:}
;

constructor ::= TIDENTIFIER:i LSPAREN field_list_opt:l RSPAREN 
	{:
		RESULT = new Constructor(parser,(Token)i,i.toString(),(List)l);
	:}
	| LSPAREN:i field_list_opt: l RSPAREN
	{:
		RESULT = new Constructor(parser,(Token)i,null,(List)l);
	:}
;

constructor_or_type ::= constructor:c
	{:
		RESULT = c;
	:}
	| TIDENTIFIER:i 
	{:
		RESULT = new Constructor(parser,(Token)i,i.toString(),null);
	:}
;

list_constructor ::= constructor_or_type:c {: RESULT = c; :}
	| list_constructor:c MULT:m 
	{: 
		RESULT = new Constructor(parser,(Token)m,(Constructor)c);
	:}
;

field_list_opt ::= field_list:l {: RESULT = l; :}
	| {: RESULT = new ArrayList(); :}
;

field_list ::= field_list:l COMMA field:f
	{:
		List list=(List)l;
		list.add(f);
		RESULT=list;
	:}
		| field:f
	{:
		List l=new ArrayList();
		l.add(f);
		RESULT=l;
	:}
;

field ::= IDENTIFIER:i COL list_constructor:c 
	{:
		RESULT = new Field(parser,(Token)i,i.toString(),(Constructor)c);
	:}
;
