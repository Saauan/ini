
\documentclass[11pt]{report}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{bussproofs}
\usepackage{listings}
\usepackage{color}
% This is the "centered" symbol
\def\fCenter{{\mbox{\Large$\rightarrow$}}}

\definecolor{LightGrey}{rgb}{0.9,0.9,0.9}
\lstset{numbers=left, numberstyle=\footnotesize, tabsize=2, backgroundcolor=\color{LightGrey}}

% Optional to turn on the short abbreviations
\EnableBpAbbreviations

% \alwaysRootAtTop  % makes proofs upside down
% \alwaysRootAtBottom % -- this is the default setting

\begin{document}
\thispagestyle{empty}

\title{INI Language Specifications}
\author{Renaud Pawlak, CINCHEO}

\date{Version pre-alpha 2\\
~\\
~\\
~\\
*** IMPORTANT WARNING ***\\
This document is not up-to-date (yet) w.r.t. the current implementation.\\
Please contact the author for full details and refer to the GitHub project.\\ \texttt{https://github.com/cincheo/ini}
}
\maketitle
\

\tableofcontents

\chapter*{Introduction}

INI is a programming language dedicated to distributed computing and pipeline creation. It natively handle processes, communication, deployment and synchronization. 

The goal of this document it is provide detailed insight on the INI language, in terms of syntax, typing, model-checking, and semantics. This document is not a tutorial or a simple way to get started with INI.

For a global overview and a motivation statement, as well as to get started with INI, please visit: \texttt{https://github.com/cincheo/ini}.

\chapter{Language features}

\section{Built-in types}

INI comes with 5 built-in types for numbers: \texttt{Double}, \texttt{Float}, \texttt{Long}, \texttt{Int}, and \texttt{Byte}. They differ on the number of bytes used to encode them (same as Java encoding). INI allows the use of \texttt{Int} and \texttt{Float} literals: e.g.:

\begin{itemize}
\item \texttt{i = 2}
\item \texttt{f = 3.1}
\end{itemize}

For getting other number types, the programmer needs to use the buit-in conversion function that will be described Section [...].

INI comes also with a \texttt{Char} type for single characters (letters and other ASCII characters) and a \texttt{String} type of character lists. Character literals are written between simple quotes and string literals are written between double quotes.

\begin{itemize}
\item \texttt{c = 'a'}
\item \texttt{s = "hello"}
\end{itemize}

\section{Functions}

\subsection{Syntax}

Functions are defined with the \texttt{function} keyword. Functions have a name that must be unique. The syntax is the following:

\begin{verbatim}
<function> := function <name>(<parameters>) { <rules> }
\end{verbatim}

Where \texttt{<name>} is the function name (an unique identifier), \texttt{<parameters>} is a coma-separated list of parameter identifiers, and \texttt{<rules>} is a list of rules that defines the function behavior. INI allows for rule-oriented programming. However, since rules are gathered into functions, it also allows for functional-like programming. The rule syntax is the following:

\begin{verbatim}
<rule> := <guard> { <body> }
\end{verbatim}

Thus, the "expanded" function syntax is:

\begin{verbatim}
function <name>(<parameters>) {
  <guard1> { <body1> }
  <guard2> { <body2> }
  ...
  <guardN> { <bodyN> }
}
\end{verbatim}

\subsection{Parameters}

Functions takes parameters which have a unique name within the function scope. Parameters are passed by reference and not by value. If the programmer wants to pass by value, it can be done using the \texttt{copy} built-in function. For instance, the function:

\begin{verbatim}
function f(a,b,c) { ... }
\end{verbatim}

Can be invoked with \texttt{f(1,2,"abc")}, if \texttt{f} expects two integers and one string. Parameters can have default values. For instance, the \texttt{a} and \texttt{c} parameters may have default values:

\begin{verbatim}
function f(a,b=0,c="") { ... }
\end{verbatim}

In that case, some parameter values are optional when invoked. For instance, \texttt{f(2,1)} invokes \texttt{f} with an empty string for \texttt{c}.

\subsection{Returned values}

A function can return a value by using a \texttt{return [<expr>]} statement within a rule body. If \texttt{<expr>} is not defined or if no return statements appear in the function, then the function returns a \texttt{Void} value. For instance:

\begin{lstlisting}
function f(a,b=0,c="") {
  ...
  <guard> {
    ...
    return b
  }
  ...
}
\end{lstlisting}

The return statement at line 5 indicates that the function returns a value of type \texttt{Int} (since \texttt{b} is an integer, as seen in the parameter's default value at line 1). Note that return statements are optional when the function returns no values, but must always be the last statement of a rule.

\subsection{Function types}

A function type is noted as \texttt{(T1,T2,...TN)->T}, where \texttt{Ti} is the expected type of the ith parameter, and \texttt{T} is the function's return type.

\subsection{Built-in Functions\label{sec:built_in_functions} }

Here is the list of built-in functions provided by INI. Built-in function have predefined function types, which are given here.

\begin{itemize}
\item \texttt{any()->Any}: returns a variable that is empty (not initialized) and without any typing constraints.
\item \texttt{clear(v:T)->Void}: initializes or re-initializes a \texttt{v} variable, passed as a parameter.
\item \texttt{copy(v:T)->T}: copies the content of a \texttt{v} variable, passed as a parameter.
\item \texttt{error(message:String)->Void}: throws an error with the given message. Throwing an error will stop the evaluation, unless it is caught by an error-event-triggered rule.
\item \texttt{eval(f:F,p1:T1,p:T2,...pN:TN)->T}: evaluates a function of type \texttt{F} passed as a reference, passing the parameters \texttt{pi} and returns the value returned by the evaluated function.
\item \texttt{print(v:T)->Void}: writes the textual representation of the passed data on the standard output stream.
\item \texttt{first(list:T*)->T}: returns the first element in the given list.
\item \texttt{key(dict:Dictionary(K,V), element:V)->K}: returns the key that corresponds to the given element in the given dictionary.
\item \texttt{max(n1:Number, n2:Number)->Number}: returns the highest number between \texttt{n1} and \texttt{n2}.
\item \texttt{min(n1:Number, n2:Number)->Number}: returns the lowest number between \texttt{n1} and \texttt{n2}.
\item \texttt{parse\_number(n:String)->Number}: parses the given string and returns it as a number.
\item \texttt{pow(n1:Number, n2:Number)->Number}: returns \texttt{n1} to the power of \texttt{n2}.
\item \texttt{print(v:T)->Void}: writes the textual representation of the passed data on the standard output stream.
\item \texttt{println(v:T)->Void}: writes the textual representation of the passed data on the standard output stream, and adds a carriage return at the end of the line.
\item \texttt{produce(channel:String, data:Any)->Void}: produces the given data on the given channel (non-blocking call).
\item \texttt{read\_keyboard()->String}: reads a line typed in by the user on the standard input stream and returns it.
\item \texttt{size(Dictionary(K,V))->Int}: returns the size of a dictionary, i.e. the number of elements in it.
\item \texttt{sleep(time:Long)->Void}: stops the current thread during \texttt{time} milliseconds.
\item \texttt{stop(rule:Any)->Void}: stops the given rule, so that it will kill the current thread and terminate the rule (an event rule will not be triggered anymore once stopped).
\item \texttt{time()->Long}: returns the current system clock time as a \texttt{Long}.
\item \texttt{to\_byte(v:T)->Byte}: converts the given variable to a byte value.
\item \texttt{to\_double(v:T)->Double}: converts the given variable to a double value.
\item \texttt{to\_float(v:T)->Float}: converts the given variable to a float value.
\item \texttt{to\_int(v:T)->Int}: converts the given variable to a integer value.
\item \texttt{to\_json(v:T)->String}: converts the given variable to a String value holding the JSON representation of the data (serialization).
\item \texttt{to\_long(v:T)->Long}: converts the given variable to a long value.
\item \texttt{to\_string(v:T)->String}: converts the given variable to a string value.
\end{itemize}

\subsection{Bindings to external functions\label{sec:bindings}}

INI only provides a minimal set of built-in functions. For all other functions, one can bind new functions (typically to Java APIs, which are available from the default implementation). Thus, to use Java objects from INI the programmers just need to define bindings from INI functions to Java constructors, methods or fields. The binding syntax is the following:

\begin{verbatim}
declare <name>(<types>) => <type> [class="string1", member="string2"]
\end{verbatim}

This binding declares a new function named \texttt{<name>}, that takes parameters typed with the given coma-separated type list (\texttt{<types>}) and returns a typed result. The corresponding Java element that will be used when invoking the function is defined thanks to the given annotation, where \texttt{string1} is the target Java class fully-qualified name, and where \texttt{string2} is one of the following:

\begin{itemize}
\item the target field name (belonging to the class),
\item the target method name (belonging to the class) followed by "(..)" to indicate that it is a method (and not a field),
\item "new(..)" to indicate that the target is a constructor of the class.
\end{itemize}

It is not needed to specify if the Java method or field is static, since INI will determine it automatically depending on the parameter types of the function. Non-static members will require to pass an instance of the type of the target class as the first parameter.

For instance, the following code defines two bound functions to call the classical \texttt{System.out.println(..)} method in Java. The \texttt{out()} function binds to the static \texttt{System.out} field, and the \texttt{java\_println()} function binds to the \texttt{Writer.println(String)} non-static method.

{ \small
\begin{verbatim}
out()=>Writer [class="java.lang.System", member="out"]
java_println(Writer,String)=>Void [class="java.io.Writer", member="println(..)"]
\end{verbatim} }

Programmers can then invoke both functions, which are well-typed thanks to the binding declarations.

\begin{verbatim}
java_println(out(),"hello Java")
\end{verbatim}

\section{Rules}

\subsection{Syntax}

Each rule has the following syntax:

\begin{verbatim}
<rule> := <guard> { <body> }
<body> := <statements> <return_statement_opt>
<guard> := <event_matcher>
         | <logical_expr>
         | <event_matcher> && <logical_expr>
\end{verbatim}

The guard is either a event matcher (for event-triggered rules) or a logical expression, or both. Events will be depicted in the next section, and we will now focus on the logical expression part of the rule.

A logical expression within a guard is formed of variable accesses, function invocations, and literals, composed together with logical operators and/or comparison operators.

\subsection{Logical operators}

Allowed logical operators within a guard are:

\begin{itemize}
\item \texttt{<expr> \&\& <expr>}: logical and, that applies to two boolean logical expressions. Like many languages, when the left-hand-side expression evaluated to false, the right-hand one is not evaluated.
\item \texttt{<expr> || <expr>}: logical or, that applies to two boolean logical expressions, and that return true without evaluating the right expression if the left one evaluates to true.
\item \texttt{! <expr>}: the not operator has two meanings depending on the type of the given expression. When \texttt{<expr>} is boolean, it is the logical inversion operator. In all other cases, the not operator will test the existence of a resulting value when evaluating the expression. To use a Java analogy, it would be similar to \texttt{<expr> == null}. Conversely, \texttt{<expr>} in INI will equal to \texttt{!!<expr>} or, in Java, to \texttt{<expr> != null}. Note that if \texttt{<expr>} is an access to an undefined variable, then the resulting value will be \texttt{null} as well.
\end{itemize}

To illustrate the use of the not operator on non-boolean expression, let us take the following process:

\begin{lstlisting}
process ping_pong() {
   @init() {
		v = any()   
   }
	!v {
		println("ping")
		v=""
	}
	v {
		println("pong")
		clear(v)
	}
}
\end{lstlisting}

This process triggers an infinite loop (it is actually a ping-pong effect between the two rules). When entering \texttt{ping\_pong}, the \texttt{v} variable is always undefined since it is not a parameter of the function. Thus, the guard \texttt{!v} at line 2 evaluates to \texttt{true}, while the guard \texttt{v} at line 6 evaluates to \texttt{false}. So, INI evaluates the first rule and sets \texttt{v} to an empty string. Since \texttt{v} is not undefined anymore, the first rule cannot apply and the second one applies, leading to clearing the content of \texttt{v} at line 8. Then, the first rule can apply again, starting the endless ping-pong game over again. Note that the rules order is not important. The following program gives exactly the same result:

\begin{lstlisting}
process ping_pong() {
   @init() {
		v = any()   
   }
	v {
		println("pong")
		clear(v)
	}
	!v {
		println("ping")
		v=""
	}
}
\end{lstlisting}

\subsection{Comparison operators}

Comparison operators are binary operators that apply to objects. In INI, using a comparison operator between two object implies that they are of the same type. If not, a typing error will occur.

\begin{itemize}
\item \texttt{<expr> == <expr>}: compares two objets and returns true if equal in terms of values.
\item \texttt{<expr> != <expr>}: compares two objets and returns false if equal in terms of values.
\item \texttt{<expr> > <expr>}: used mainly to compare two numbers, but can actual apply to any comparable objets.
\item \texttt{<expr> >= <expr>}: used mainly to compare two numbers, but can actual apply to any comparable objets.
\item \texttt{<expr> < <expr>}: used mainly to compare two numbers, but can actual apply to any comparable objets.
\item \texttt{<expr> <= <expr>}: used mainly to compare two numbers, but can actual apply to any comparable objets.
\end{itemize}

\subsection{Regular expression match operator\label{subsubsec:regexp}}

In order to match strings in a concise way, INI provides a match operator $\sim$, with can match a string against a regular expression \cite{friedl2006} and bind matching groups (if any) to INI variables. For example:

\texttt{"a b c"} $\sim$ \texttt{regexp("(.) (b) (.)",v1,v2,v3)} will match and be evaluated to \texttt{true}. Since there are three groups (between parenthesis), the three match sub-results will be bound to the given variables \texttt{v1}, \texttt{v2}, and \texttt{v3}. Thus, once the match is done, we will have \texttt{v1="a"}, \texttt{v2="b"}, and \texttt{v3="c"}. For more information on regular expressions as used in INI, read the Javadoc for the \texttt{java.regexp.Pattern} class and refer to \cite{friedl2006}.

Example:

\begin{lstlisting}
function greetings(sentence) {
	sentence ~ regexp("Hello (.*)",name)
		|| sentence ~ regexp("Hi (.*)",name) {
		println("Hello to "+name)
		return
	}
	sentence ~ regexp("Bye (.*)",name)
		|| sentence ~ regexp("See you (.*)",name) {
		println("Bye to "+name)
		return
	}
}
\end{lstlisting}

This function matches the given sentence to determine who it is said hello or bye to. Typically, the invocation \texttt{greetings("See you Renaud")} will print out \texttt{"Bye to Renaud"}. Note the use of the return statement at lines 5 and 10 to ensure that rules are applied once at best.

\subsection{Event-triggered rules}

Besides rules that are applied because the logical expression of the guard evaluates to true, some rules can also be event-triggered. An event rules takes configuration parameters as an annotation, and will provide input arguments when fired. Thus, an event-rule guard starts with one event expression, of the form \texttt{@<event>(<input arguments>) [<configuration parameters>]}. Configuration parameters may be optional depending on the event. Some events are evaluated synchronously (in the process thread), but some event are fired asynchronously and concurrently (multi-threaded evaluation).

\section{Synchronous events}

Synchronous events are evaluated within the process evaluation thread. When a synchronous event evaluates, no other rule or event can be evaluated concurrently. 

\subsection{\texttt{@init} event}

As the name says, \texttt{@init}-trigger rules are invoked when the process starts evaluating. It is the right place to initialize the variables that may need to be used within the other rules. This event takes no parameters.

For example, to repeat a rule n times:

\begin{lstlisting}
process f(n) {
  @init() {
    i=0
  }
  i < n {
    // repeated code here
    ...
    i++
  }
}
\end{lstlisting}

Note that event-based rules can also have a predicate for triggering the rule or not. For instance, if \texttt{n <= 0}, one may want to stop the process evaluation and print out a message:

\begin{lstlisting}
process f(n) {
  @init() && n<=0 {
    println("wrong repeat value")
    return
  }
  @init() && n>0 {
    i=0
  }
  i < n {
    // repeated code here
    ...
    i++
  }
}
\end{lstlisting}

\subsection{\texttt{@end} event}

On the contrary to the \texttt{@init} event, \texttt{@end} is triggered when no more rule apply, and when the process is about to return (not including explicit return statements, which do no trigger the \texttt{@end} event). Note that any state change in an \texttt{@end}-triggered rule body will never lead to any other rule re-evaluation, even if the state change makes an existing rule applicable again.

\subsection{\texttt{@update} event}

The \texttt{@update(old\_value, new\_value) [variable = <variable>]} event occurs when the given variable is modified by the program (i.e. by one of the evaluated rules). For instance, \texttt{@update(b,c) [variable = a]} is triggered if the value of \texttt{a} is modified. The old value of \texttt{a} will be kept in the variable \texttt{b} and the new value of \texttt{a} will be kept in the variable \texttt{c}.

The \texttt{@update} event is particular because it is evaluated synchronously by default, but it can be set to be asynchronous, as explained later.

\subsection{\texttt{@error} event}

The \texttt{@error[message:String]()} event occurs when an error is thrown during the process's evaluation.

\section{Processes\label{sec:processes}}

Processes are very similar to functions, except that they run asynchronously and concurrently. 

\subsection{Getting started with processes}

Within a process, it is allowed to to use asynchronous events, which are also run concurrently to other events within the process. An example of an asynchronous event is the \texttt{@every} event, which is triggered at regular intervals defined by the \texttt{time} annotation parameter. For example, to define a process that says \texttt{"hello"} every second:

\begin{lstlisting}
process p() {
 @every() [time=1000] {
  println("hello")
 }
}
\end{lstlisting}

Processes are spawned just by invoking them as regular functions. The main difference is that this invocation is not blocking by default. For instance, to start the previously defined process, just write:

\begin{lstlisting}
process main() {
 @init() {
  p()
 }
}
\end{lstlisting}

Processes may take arguments exactly like functions. The following program will write \texttt{"hi"} every second:

\begin{lstlisting}
process main() {
 @init() {
  p("hi")
 }
}
process p(msg) {
 @every() [time=1000] {
  println(msg)
 }
}
\end{lstlisting}

\subsection{Inter-process communication\label{sec:communication}}

Process communicate with each other through channels. A channel has a unique name and can be used to produce and consume data. To produce data in a channel, a function or a process must invoke the \texttt{produce} built-in function. This is a non-blocking call. On the other end of the channel, a process must consume the data using the  \texttt{@consume} event. Since it is an asynchronous event, only processes can use the  \texttt{@consume} event. For instance, the following program starts a process \texttt{p} and send a \texttt{"hello"} message through a channel \texttt{c}. Note that the  \texttt{p} process never terminates and will wait on subsequent data on the channel \texttt{c} to be produced.

\begin{lstlisting}
process main() {
 @init() {
  p()
  produce("c", "hello")
 }
}
process p() {
 @consume(msg) [channel="c"] {
  println(msg)
 }
}
\end{lstlisting}

\subsection{Stopping processes}

Since processes usually never end, it may be useful to force them to terminate. This can be achieved by terminating all the events in the process, which can be done with the \texttt{stop} built-in function. This function will take a parameter, which is an event rule referred to thanks to the name of the rule. For instance, to name a \texttt{@consume} event rule \texttt{c}, just write: \texttt{c: @consume(...)}. 

Once all the event rules are terminated, the process terminates and the \texttt{@end()} event will be triggered. As an example, the following program launches a process that will print an \texttt{"hello"} message an will terminate right after:

\begin{lstlisting}
process main() {
 @init() {
  p()
  produce("c", "hello")
 }
}
process p() {
 c: @consume(msg) [channel="c"] {
  println(msg)
  stop(c)
 }
 @end() {
   println("bye")
 }
}
\end{lstlisting}

\section{Asynchronous events\label{sec:asynchronous_events}}

Asynchronous events can only be used in process definitions, and are evaluated concurrently with other rules or events in the process. 

\subsection{\texttt{@every} event}

The \texttt{@every() [time = interval:Int]} event occurs every \texttt{interval} milliseconds.

\subsection{\texttt{@cron} event}

The \texttt{@cron() [pattern:String]} event occurs on times indicated by the \texttt{pattern} UNIX CRON pattern expression. CRON is a task scheduler that allows the concise definition of repetitive task within a single (and simple) CRON pattern \cite{franta1977}. A UNIX crontab-like pattern is a string split in five space separated parts. Each part is intended as:

\begin{enumerate}
\item Minutes sub-pattern. During which minutes of the hour the event should occur? The values range is from 0 to 59.
\item Hours sub-pattern. During which hours of the day should the event occur? The values range is from 0 to 23.
\item Days of month sub-pattern. During which days of the month should the event occur? The values range is from 1 to 31. The special value "L" can be used to recognize the last day of month.
\item Months sub-pattern. During which months of the year should the event occur? The values range is from 1 (January) to 12 (December), otherwise this sub-pattern allows the aliases "jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov" and "dec".
\item Days of week sub-pattern. During which days of the week should the event occur? The values range is from 0 (Sunday) to 6 (Saturday), otherwise this sub-pattern allows the aliases "sun", "mon", "tue", "wed", "thu", "fri" and "sat".
\end{enumerate}

Some examples:

\begin{itemize}
\item \texttt{"5 * * * *"}: This pattern causes the event to occur once every hour, at the begin of the fifth minute (00:05, 01:05, 02:05 etc.).
\item \texttt{"* * * * *"}: This pattern causes the event to occur every minute.
\item \texttt{"* 12 * * Mon"}: This pattern causes the event to occur every minute during the 12th hour of Monday.
\item \texttt{"* 12 16 * Mon"}: This pattern causes the event to occur every minute during the 12th hour of Monday, 16th, but only if the day is the 16th of the month.
\item \texttt{"59 11 * * 1,2,3,4,5"}: This pattern causes the event to occur at 11:59AM on Monday, Tuesday, Wednesday, Thursday and Friday.
\item \texttt{"59 11 * * 1-5"}: This pattern is equivalent to the previous one.
\end{itemize}

\subsection{\texttt{@consume} event}

The \texttt{@consume(value:Any) [channel = name:String]} event occurs when a data is consumed from the channel \texttt{name}. The consumed data is then passed in the \texttt{value} variable.

\subsection{\texttt{@update} event (asynchronous mode)}

The \texttt{@update(old\_value, new\_value) [variable = <variable>]} event occurs when the given variable is modified by the program (i.e. by one of the evaluated rules). For instance, \texttt{@update(b,c) [variable = a]} is triggered if the value of \texttt{a} is modified. The old value of \texttt{a} will be kept in the variable \texttt{b} and the new value of \texttt{a} will be kept in the variable \texttt{c}.

The \texttt{@update} event is particular because it is evaluated synchronously by default, but it can be set to be asynchronous, by setting the optional \texttt{mode} annotation parameter to \texttt{"async"}. For instance: \texttt{@update(b,c) [variable = a, mode = "async"]}.

\section{Synchronization of events}

Since asynchronous events can run concurrently, it is sometimes necessary to use synchronization to avoid undesirable side effects. INI provides a simple synchronization construct with the following syntax, which just complements the declaration of a rule: \texttt{\$(r1, r2, ... rn) <guard> \{ <statements> \}}. It means that the declared rule cannot run if one of the \texttt{r1, r2, ... rn} rule is executed.

Rule names are defined trough labels, for example, to name a rule \texttt{r}, just add the label in front of the rule as: \texttt{r:<guard> \{ <statements> \}}. For example, if we have a \texttt{@consume} event rule that we want to be executed only once at a time, then we can just write  \texttt{\$(c) c:@consume(v) \{ <statements> \}}, so that the event rule \texttt{c} synchronizes on itself.

In the following example, the two rules here are made to be mutually exclusive so that the value of the \texttt{tick} variable cannot be modified concurrently and remains consistent within the every and consume events.

\begin{lstlisting}[numbers=none]
process main() {
	@init() {
		tick = 0
	}
	$(c) e:@every() [time=1000] {
		tick++
	}
	$(e) c:@consume(v) [channel="c"] {
		println("new event at tick = "+tick)
		tick=0
	}
}
\end{lstlisting}

\section{Dictionaries, lists, and sets}

\subsection{Dictionary definition and access}

Dictionaries are natively supported by INI. A dictionary is automatically defined when accessed through the dictionary access expression that uses square brackets: \texttt{dict[key]}. Keys and values within dictionaries are of any type, but shall all be of the same type for a given dictionary. For instance the following statement list is valid:

\begin{lstlisting}[numbers=none]
m["key1"] = 1
m["key2"] = 2
println(m["key2"])
\end{lstlisting}

On the other hand, the following statement list is not valid because the first line initializes \texttt{m} to be a dictionary of integer values accessed through string keys and:

\begin{itemize}
\item the key is an integer at line 2,
\item the value is a string at line 3,
\item there are no typing errors at line 4.
\end{itemize}

\begin{lstlisting}
dict["key1"] = 1
dict[1] = 2
dict["key2"] = "test"
println(dict["key2"])
\end{lstlisting}

Note that the size of a dictionary (i.e. the number of elements in it) can be retrieved with the \texttt{size} built-in function (see Section \ref{sec:built_in_functions}).  Emptying a dictionary or removing an entry is done with the \texttt{clear} function.

\subsection{List definition and access}

In INI, a list is simply a dictionary where keys are integers.

\subsection{Integer sets}

To allow easy iteration on lists, INI provides a constructor for set of integers. A set of integers is defined with two bounds: \texttt{[min..max]}. For instance, the set that contains all the integers between \texttt{0} and \texttt{10} (bounds included) is written \texttt{[0..10]}.

\subsection{Set selection expressions\label{subsubsec:setselectionexpressions}}

Set can be used in set selection expressions that allows the programmer to randomly select elements in a set and bind their values to local variables. A selection condition must be used to select the elements upon a given criteria. For instance, to select two integers \texttt{i} and \texttt{j} that are contained within 0 and 10, so that \texttt{i} < \texttt{j}, one can write the following set selection expression:

\begin{lstlisting}[numbers=none]
i, j of [0..10] | i < j
\end{lstlisting}

Set selection expressions must be used in guards. The difference between a set selection guard and a regular guard is that the former one will be evaluated to true until all the possible values have been picked from the set. In other words, the guard will stop matching only once none of the set elements fit the selection condition.

Example: sorting the elements of a list (see Section [...]).

\begin{lstlisting}
function sort1(s) {
	i of [0..size(s)-2] | s[i] > s[i+1] {
		swap(s[i],s[i+1])
	}
	@end() {
		return s
	}
}
\end{lstlisting}

As we will see in the next section, set selection expressions can be used to select instances of types that have been constructed by the program. This feature requires the use of user-defined types.

\section{User-defined types}

A user-defined type is a way for the programmer to define complex structures. Structures contains values stored in named fields, which need to be explicitly typed when defined by the programmer. Section [...] gives an example that uses types.

\subsection{Simple structured types}

To define a new type, the programmer uses the \texttt{type} keyword and sets a name that must be unique, and a set of typed field. Note that in INI, type name must start with an uppercased letter. For example, to define a \texttt{Person} type that has a name and an age, one may want to write:

\begin{lstlisting}[numbers=none]
type Person = [name:String, age:Int]
\end{lstlisting}

To use a type, the programmer must instantiate the type using one of its constructor. For a simple type, there is only one constructor named by the name of the type. So, for constructing a new person and store it in a \texttt{p} variable:

\begin{lstlisting}[numbers=none]
p = Person[name="Renaud", age=37]
\end{lstlisting}

Later on, the program can access the object's fields using the dotted notation:

\begin{lstlisting}[numbers=none]
println(""+p.name+" is "+p.age)
\end{lstlisting}

Note that field initialization is not mandatory. For instance, one can construct a person with undefined age or name.

Finally, types can be recursively defined. For instance, one can use the \texttt{Person} type within the \texttt{Person} type definition itself. For instance, we may want to add two fields for the parents of the person:

\begin{lstlisting}[numbers=none]
type Person = [name:String, age:Int,
               father:Person, mother:Person]
\end{lstlisting}

We may even want to add the children, as a person list:

\begin{lstlisting}[numbers=none]
type Person = [name:String, age:Int,
               father:Person, mother:Person,
               children:Person*]
\end{lstlisting}

Note that when using such types, INI checks that the used objects work on the right fields with the correct types.

\subsection{Algebraic types}

Algebraic types are an extension of simple structured type that allow the definition of types that have different constructors. Algebraic types in INI are not actual pure algebraic types since they contain named fields that do not need to be initialized. However, they are defined and used in a very similar way, as shown in the Fibonacci example of Section [...]. Algebraic types can be related to AST (Abstract Syntax Trees) in the sense that they allow the definition of typed trees structures.

For instance, we can define a type for expressions that include typical arithmetic operations on floating point numbers.

\begin{lstlisting}[numbers=none]
type Expr = Number[value:Float]
          | Plus[left:Expr,right:Expr]
          | Mult[left:Expr,right:Expr]
          | Div[left:Expr,right:Expr]
          | Minus[left:Expr,right:Expr]
          | UMinus[operand:Expr]
\end{lstlisting}

Once define, the programmer can instantiate any expression using the constructors. For example to instantiate the expression \texttt{-(3.0*2.0+1.0)}:

\begin{lstlisting}
expr = UMinus[operand=Plus[
  left=Mult[
    left=Number[value=3.0],
    right=Number[value=2.0]],
  right=Number[value=1.0]]]
\end{lstlisting}

\subsection{Type set selection expressions}

In Section \ref{subsubsec:setselectionexpressions}, we have seen the set selection expression that allows to select values within a set. Each object constructed with a user type constructor is automatically part of an instance set, which is named after the constructor name. Thus, it is possible to select instances using the set selection construct. For example, the following rule raises an error if a number has a undefined value:

\begin{lstlisting}[numbers=none]
n of Number | !n.value {
    error("invalid number value")
}
\end{lstlisting}

Note that sets are local to the functions that construct the instances.

\subsection{Type set match expressions}

In Section \ref{subsubsec:regexp}, we have seen the match operator ($\sim$) for string, which is based on regular expressions. The match operator can also be used to match type instances. It an be used similarly to the match construction in the CAML language. For example, we can use the match operator to implement a basic expression printer (see function \texttt{expr\_str} at line 19) and evaluator (function \texttt{expr\_val} at line 40).

{ \footnotesize
\begin{lstlisting}
type Expr = Number[value:Float]
          | Plus[left:Expr,right:Expr]
          | Mult[left:Expr,right:Expr]
          | Div[left:Expr,right:Expr]
          | Minus[left:Expr,right:Expr]
          | UMinus[operand:Expr]

function main() {
	expr = UMinus[operand=Plus[
	  left=Mult[
	    left=Number[value=3.0],
	    right=Number[value=2.0]],
      right=Number[value=1.0]]]
	println("The value of "+expr_str(expr)+" is "+expr_val(expr))
}

function expr_str(expr) {
	case {
		expr ~ Number[value] {
			return to_string(expr.value)
		}
		expr ~ Plus[left,right] {
			return "("+expr_str(expr.left)+"+"+expr_str(expr.right)+")"
		}
		expr ~ Mult[left,right] {
			return "("+expr_str(expr.left)+"*"+expr_str(expr.right)+")"
		}
		expr ~ Minus[left,right] {
			return "("+expr_str(expr.left)+"-"+expr_str(expr.right)+")"
		}
		expr ~ Div[left,right] {
			return "("+expr_str(expr.left)+"/"+expr_str(expr.right)+")"
		}
		expr ~ UMinus[operand] {
			return "-("+expr_str(expr.operand)+")"
		}
	}
}

function expr_val(expr) {
	case {
		expr ~ Number[value] {
			return expr.value
		}
		expr ~ Plus[left,right] {
			return expr_val(expr.left)+expr_val(expr.right)
		}
		expr ~ Mult[left,right] {
			return expr_val(expr.left)*expr_val(expr.right)
		}
		expr ~ Minus[left,right] {
			return expr_val(expr.left)-expr_val(expr.right)
		}
		expr ~ Div[left,right] {
			return expr_val(expr.left)/expr_val(expr.right)
		}
		expr ~ UMinus[operand] {
			return -expr_val(expr.operand)
		}
	}
}
\end{lstlisting} }

\section{Lambdas}

Functions can be assigned to variables and passed as parameters to other functions. 

The following program illustrates the use of function variables. It defines a \texttt{sort} function at line 9 that takes a list \texttt{l} to sort and a comparison function to compare the elements of the list. This function is passes in the \texttt{comparator} parameter.

{ \small
\begin{lstlisting}
function main() {
	l = "a string to sort"
	sort(l,compare)
	println("result: "+l)
}

process sort(l, comparator) {
	i of [0..size(l)-2] | eval(comparator,l[i],l[i+1]) > 0 {
		swap(l[i],l[i+1])
	}
}

function compare(e1,e2) {
	case {
		e1 > e2 { return 1 }
		e1 < e2 { return -1 }
		e1 == e2 { return 0 }
	}
}
\end{lstlisting} }

\section{Imports\label{sec:imports}}

Since all the functions should not be defined within a single file, INI programs can start with a list of import clauses. For example:

\begin{lstlisting}[numbers=none]
import "ini/examples/lib_io.ini"
\end{lstlisting}

Imports allow the definition and use of function libraries. In particular, it is recommended to define bindings (see Section \ref{subsubsec:bindings}) within external files and to import them when required.

\section{User-defined events}

Besides the built-in events, INI allows developers to create their own events. For example, we will try to create a simple custom event. This event will copy one file to another file. We need two in parameters: one for source file name and another for destination file name. Besides, we will store the time needed for copy process in the variable \texttt{v} and the result of this process (whether successful or not) in the variable \texttt{s}. In INI, \texttt{t} and \texttt{s} are examples of out parameters.
\begin{lstlisting}

package ini.ext.events;

import ini.ast.AtPredicate;
import ini.ast.Rule;
import ini.eval.IniEval;
import ini.eval.at.At;
import ini.eval.data.Data;
import ini.eval.data.RawData;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;

public class AtCopyFile extends At {
	public String sourceFileName;
	public String destFileName;
	public long copyTime;
	public boolean success = false;
	Map<String, Data> variables = new 
        HashMap<String, Data>();
	Map<Thread, At> threadAt = new HashMap<Thread, At>();
	@Override
	public void eval(final IniEval eval) {
		final Data sfn = getInContext().get("source");
		sourceFileName = (String) sfn.getValue();
		final Data dfn = getInContext().get("destination");
		destFileName = (String) dfn.getValue();
		new Thread() {
			@Override
			public void run() {
				try {
					long beginTime = System.currentTimeMillis();
					File sourceFile = new File(sourceFileName);
					File destFile = new File(destFileName);
					InputStream in = new 
                        FileInputStream(sourceFile);
					OutputStream out = 
                        new FileOutputStream(destFile);
					byte[] buffer = new byte[1024];
					int fLength;
					while ((fLength = in.read(buffer)) > 0) {
						out.write(buffer, 0, fLength);
					}
					in.close();
					out.close();
					long endTime = System.currentTimeMillis();
					copyTime = endTime - beginTime;
					success = true;
					variables.put(getAtPredicate().outParameters.
                            get(0).toString(),
							new RawData(copyTime));
					variables.put(getAtPredicate().outParameters.
                            get(1).toString(),
							new RawData(success));
					this.setName("Demo copy thread");
					execute(eval, variables);
					terminate();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}.start();
	}
}
\end{lstlisting}
Now we can write a simple INI program to test this event.
\begin{lstlisting}
@copy_file[String, String](Long, Boolean)=>
                            "ini.ext.events.AtCopyFile"
function main() {
 @copy_file(t,s)[source = "file.exe",destination = 
                "fileCopy.exe"] {
  println("Time for copy: " + t + " milliseconds")
 }
}
\end{lstlisting}
Before using the event, we need to declare it as you see in the first line of our program. The types of configuration and out parameters should be declared. In our example, we have two in parameters with type \texttt{String}. Besides, we have two out parameters, one with type \texttt{Long} and another with type \texttt{Boolean}. Moreover, a source code associated with the event also must be declared. When we run this program, it will copy a file \texttt{file.exe} to a file \texttt{fileCopy.exe}. The time needed for this process (in milliseconds) also will be displayed.

\chapter{The INI type system}

\section{Definitions}

INI comes with 5 built-in types for numbers: $Double$, $Float$, $Long$, $Int$, and $Byte$. They differ on the number of bytes used to encode them (same as Java encoding). INI comes also with a $Char$ type for single characters (letters and other ASCII characters) and a $Boolean$ type that takes only $true$ and $false$ values.
Finally, INI provides built-in dictionary types: $Dictionary(K,V)$. Dictionary types are dependent types with a key type $K$ and a value type $V$. When $K=Int$, it means that the type is a list in the INI definition (in reality, it is more of an indexed set). Syntactically, lists can be noted with the * notation:

\begin{center}
$T* \widehat= Dictionary(Int,T)$
\end{center}

A list of $Char$ (i.e. a $Char*$) is a $String$ type (note that $String$ and $T*$ types are actually aliases and do not exist as real types in the INI internal type representation).

\begin{center}
$String \widehat= Char* \widehat= Dictionary(Int,Char)$
\end{center}

INI types can be ordered with a type relation $\succ$. $A \succ B$ means that $A$ is a super-type of $B$, i.e. $A$ is assignable from $B$, whereas the contrary is not true. By default, number types in INI are ordered so that it is not possible to assign more generic numbers to less generic numbers.

\begin{center}
$Double \succ Float \succ Long \succ Int \succ Byte$
\end{center}

\section{Type Inference}

As said in Section \ref{sec:counting_occurences_in_a_list}, most types in INI are calculated with the type inference engine, which allows the programmers to say very few about the typing. The kernel of this type inference is based on a Herbrand unification algorithm, as depicted by Robinson in \cite{robinson1965}. The typing algorithm is enhanced with polymorphic function support, abstract data types (or algebraic types) support, and with internal sub-typing for number types.

Thus, INI works with the following steps:

\begin{enumerate}
\item the parser constructs the AST;
\item an AST walker constructs the typing rules that should be fulfilled for each AST node and add them to a constraint list;
\item a unification algorithm is run on the type constraints, if conflicts are detected, they are added to the error list;
\item if errors are found, they are reported to the user and INI does not proceed to the execution phase.
\end{enumerate}

\section{Type Inference rules}

\subsection{Initiation rules}

In order to infer types for the program, we first need some initiation rules. Here is a rule that states that undefined values have any type, i.e. their type is an unconstrained type variable.

\begin{center}
\AxiomC{}
\LeftLabel{(NULL)}
\UIC{$\vdash null: T $}
\DP
\end{center}

Note that INI also has an internal \texttt{Void} type for functions returning no values. We then have some rules for literals, which can directly be inferred as resolved types:

\begin{itemize}
\item string literals such as \texttt{"abc"} will be typed as \texttt{String},
\item character literals such as \texttt{'a'} will be typed as \texttt{Char},
\item float literals such as \texttt{3.14} will be typed as \texttt{Float},
\item integers such as \texttt{1} will be typed as \texttt{Int},
\item \texttt{true} and \texttt{false} literals will be typed as \texttt{Boolean},
\end{itemize}

\subsection{Assignments}

When an assignment is made from a resolved type (for instance from a literal, such as \texttt{x=2.0}), then the type of the assignee equals to the type of the assignment (for instance \texttt{x:Float}).

\begin{center}
\AxiomC{$\vdash x:T$} \AxiomC{$\vdash y:T$}
\LeftLabel{(ASSIGNDEF)}
\BIC{$\vdash x = (y:T)$}
\DP
\end{center}

When the assignment is made from an unresolved type (e.g. \texttt{x=y}), then the type of the assignee is a super-type for the type of the assignment.

\begin{center}
\AxiomC{$\vdash x:U$} \AxiomC{$\vdash y:V$}
\LeftLabel{(ASSIGN)}\RightLabel{$[U \succeq V]$}
\BIC{$\vdash x = y$}
\DP
\end{center}

\subsection{Logical operators}

Logical operators are easy to deal with since the result must be of the \texttt{Boolean} type. There are no constraints on the operands since undefined values mean \texttt{false} and defined ones mean \texttt{true} from a boolean perspective.

\begin{center}
\AxiomC{$\vdash x:T$} \AxiomC{$\vdash y:U$}
\LeftLabel{(LCOMP)}
\BIC{$\vdash (x \texttt{ op } y):Boolean$}
\DP
\end{center}
\begin{center}with  \texttt{op} $\in \{$\texttt{\&\&, ||}$\}$\end{center}

\subsection{Comparison operators}

Comparators imply that the result must be \texttt{Boolean}. Operands must be comparable, which is the case for all objects in INI. Moreover, we enforce that the compared object must be of the same type.

\begin{center}
\AxiomC{$\vdash x:T$} \AxiomC{$\vdash y:T$}
\LeftLabel{(COMP)}
\BIC{$\vdash (x \texttt{ op } y):Boolean$}
\DP
\end{center}
\begin{center}with  \texttt{op} $\in \{$\texttt{==, !=, <, <=, >, >=}$\}$\end{center}

\subsection{Division}

Division must occur between two expressions of the same type, which both must be subtypes of \texttt{Double} (e.g. \texttt{Float} or \texttt{Int}). Division returns a \texttt{Float} whatever the operands' type is, thus avoiding loss of precision for integers.

\begin{center}
\AxiomC{$\vdash x:T$} \AxiomC{$\vdash y:T$}
\LeftLabel{(DIV)}\RightLabel{$[T \preceq Double]$}
\BIC{$\vdash (x \texttt{ / } y):Float$}
\DP
\end{center}

\subsection{Multiplication and minus}

Multiplication and minus operations must occur between two expressions of the same type, which both must be subtypes of \texttt{Double} (e.g. \texttt{Float} or \texttt{Int}). They will return the same type as the operands' type.

\begin{center}
\AxiomC{$\vdash x:T$} \AxiomC{$\vdash y:T$}
\LeftLabel{(MULTMINUS)}\RightLabel{$[T \preceq Double]$}
\BIC{$\vdash (x \texttt{ op } y):T$}
\DP
\end{center}
\begin{center}with  \texttt{op} $\in \{$\texttt{-, *}$\}$\end{center}


\subsection{The plus operator}

There are two case for the plus operator. In the first case, it is uses as a string concatenation operator. For that, like in Java, the first operand must be of a resolved \texttt{String} type. If it is the case, the type of the second operand does not matter and the overall expression will be typed as a \texttt{String} and the \texttt{String} type will propagate. Typically, the \texttt{"a"+b} expression is a string concatenation case.

\begin{center}
\AxiomC{$\vdash x:String$} \AxiomC{$\vdash y:T$}
\LeftLabel{(PLUS1)}
\BIC{$\vdash (x \texttt{ + } y):String$}
\DP
\end{center}

The second case occurs when the type of the first operand's type is undetermined. We then fall back to the arithmetic plus, which behaves exactly like $MULTMINUS$ in terms of typing.

\begin{center}
\AxiomC{$\vdash x:T$} \AxiomC{$\vdash y:T$}
\LeftLabel{(PLUS2)}\RightLabel{$[T \preceq Double]$}
\BIC{$\vdash (x \texttt{ + } y):T$}
\DP
\end{center}

\subsection{The list concatenation operator (TBD)} 

The list concatenation operator is \texttt{\&}.

\begin{center}
\AxiomC{$\vdash x:T*$} \AxiomC{$\vdash y:T*$}
\LeftLabel{(CONCAT)}
\BIC{$\vdash (x \texttt{ \& } y):T*$}
\DP
\end{center}

\subsection{Unary minus (sign inversion)}

The unary minus operator expects an operand which is a number and will return a result of the same type.

\begin{center}
\AxiomC{$\vdash x:T$}
\LeftLabel{(UMINUS)}\RightLabel{$[T \preceq Double]$}
\UIC{$\vdash (\texttt{-} x):T$}
\DP
\end{center}

\subsection{Post operators}

The post increment/decrement operators both expect an operand which is a number and will return a result of the same type.

\begin{center}
\AxiomC{$\vdash x:T$}
\LeftLabel{(POSTOP)}\RightLabel{$[T \preceq Double]$}
\UIC{$\vdash (x\texttt{ postop}):T$}
\DP
\end{center}
\begin{center}with  \texttt{postop} $\in \{$\texttt{++, --}$\}$\end{center}

\subsection{The not operator}

The logical negation operator returns a boolean, but does not force any constraint on the operand (undefined means \texttt{false} and defined means \texttt{true} for non-boolean objects).

\begin{center}
\AxiomC{$\vdash e:T$}
\LeftLabel{(NOT)}
\UIC{$\vdash (\texttt{!}e):Boolean$}
\DP
\end{center}

\subsection{The match operator}

Within a guard a match operator can be used to match strings with regular expressions and bind the results to some variables. For instance \texttt{"a b c"} $\sim$ \texttt{regexp("(.) (b) (.)",v1,v2,v3)} will match and be evaluated to \texttt{true}. Since there are three groups (between parenthesis), the three match sub-results will be bound to the given variables. Thus, once the match is done, we will have \texttt{v1="a"}, \texttt{v2="b"}, and \texttt{v3="c"}. With regard to typing, all the bound variables are strings.

\begin{center}
\AxiomC{$\vdash x:String$} \AxiomC{$\vdash y:String$} \AxiomC{$\{\vdash v_i:String\}_{i \in [1..n]}$}
\LeftLabel{(MATCH1)}
\TIC{$\vdash (x \sim \texttt{regexp(}y,v_1,v_2,...,v_n\texttt{)}):Boolean$}
\DP
\end{center}

A match operator can also be used to match a constructor's instance with some constraints given by boolean logical expressions on the constructor's fields.

\begin{center}
 \AxiomC{$\{\vdash e_i:Boolean\}_{i \in [1..n]}$}
\LeftLabel{(MATCH2)} \RightLabel{$ [ \{ freevars(e_i)=\emptyset \}_{i \in [1..n]} ] $}
\UIC{$\vdash (e \sim C[e_1,e_2,...,e_n]):Boolean$}
\DP
\end{center}

\subsection{Dictionary access}

A dictionary access node such as \texttt{x[y]} allows to say that the resulting type of the expression is \texttt{V}, if \texttt{x} is of type \texttt{Dictionary(K,V)}.

\begin{center}
\AxiomC{$\vdash x:Dictionary(K,V)$} \AxiomC{$\vdash y:K$}
\LeftLabel{(DICTACCESS)}
\BIC{$\vdash x[y]: V $}
\DP
\end{center}

\subsection{Field access}

For a field access such as \texttt{x.f}, the type of the accessed expression \texttt{x} must have a field of the right name and type. Note that, when using match expressions, by construction, it is often the case that the type of the accessed expression is already resolved.

\begin{center}
\AxiomC{$\vdash T.f:V $}
\LeftLabel{(FIELDACCESS)}
\UIC{$\vdash (x:T).f: V $}
\DP
\end{center}

\subsection{Function invocation}

For an invocation, the rule implies some constraints between the function type and the types of the result and of the parameter expressions. To support polymorphism, the function body is evaluated within its own environment, so that each invocation has its own set of constraints.

\begin{center}
\AxiomC{$\vdash f:T_1,T_2,...,T_n \rightarrow T$}  \AxiomC{$\{\vdash e_i:T_i\}_{i \in [1..n]}$}
\LeftLabel{(INVOCATION)}\RightLabel{$[new(env)]$}
\BIC{$\vdash f(e_1,e_2,...,e_n):T_1,T_2,...,T_n \rightarrow T$}
\DP
\end{center}

\subsection{List definition}

Lists definitions are done with the following syntax: \texttt{[e1, e2, ... en]}, where all the expressions must be of the same type \texttt{T}. Then the type of the resulting list is \texttt{T*} (equivalent to \texttt{Dictionary(Int,T)})

\begin{center}
\AxiomC{$\{\vdash e_i:T\}_{i \in [1..n]}$}
\LeftLabel{(LISTDEF)}
\UIC{$\vdash  \texttt{[}e_1,e_2,...,e_n\texttt{]}:T*$}
\DP
\end{center}

\subsection{Return statement}

A return statement implies that the enclosing function's return type is \texttt{Void}. Note that, in addition, the function's return type is \texttt{Void} if no return statements appear in the function body.

\begin{center}
\AxiomC{$\vdash f:\_ \rightarrow Void$}
\LeftLabel{(RETURN)}
\UIC{$\vdash (\texttt{return}) \in f$}
\DP
\end{center}

A return statement with an expression implies that the enclosing function's return type is of the expression's type.

\begin{center}
\AxiomC{$\vdash f:\_ \rightarrow T$}  \AxiomC{$\vdash e:T$}
\LeftLabel{(RETURNEXPR)}
\BIC{$\vdash (\texttt{return } e) \in f$}
\DP
\end{center}

\subsection{Type instantiation}

One can construct an instance of an algebraic type using one of its constructor. For instance, a algebraic type defined as: type \texttt{A = C[f1:T1, f2:T2, ... fn,Tn]} has one constructor \texttt{C} with n typed fields. A constructor \texttt{C} of an algebraic type \texttt{A} is typed with a type of the same name (\texttt{C}), with $C \preceq A$. When an instance of \texttt{A} is constructed using \texttt{C} through the expression \texttt{C[f1=e1,f2=e2, ... fn=en]}, then the type of each expression \texttt{ei} must be of the type of the field \texttt{fi}, as declared in the algebraic type definition (i.e. \texttt{Ti}).

\begin{center}
\AxiomC{$\{ \vdash C.f_i:T_i\}_{i \in [1..n]} $} \AxiomC{$\{\vdash e_i:T_i\}_{i \in [1..n]} $}
\LeftLabel{(CONSTRUCTOR)}%\RightLabel{$[\{U_i \succeq V_i\}_{i \in [1..n]}]$}
\BIC{$\vdash \texttt{C[}f_1\texttt{=}e_1\texttt{,} f_2\texttt{=}e_2\texttt{,} ... f_n\texttt{=}e_n\texttt{]} : C $}
\DP
\end{center}
\begin{center}with  $T$, the type that corresponds to the $C$ constructor, which is part of an algebraic type\end{center}

\subsection{Integer set declaration}

An integer set declaration allows the programmer to declare a integer domain with min and max bounds. The syntax is \texttt{[e1..e2]} where \texttt{e1} is the min bound and \texttt{e2} is the max one. Both min and max bound expressions must be of type \texttt{Int}, and the resulting type is an \texttt{Set(Int)}.

\begin{center}
\AxiomC{$\vdash e_1:Int$} \AxiomC{$\vdash e_2:Int$}
\LeftLabel{(INTSET)}
\BIC{$\vdash [e_1\texttt{..}e_2]:Set(Int)$}
\DP
\end{center}

\subsection{Set selection}

Within a set expression, one can select elements in a set, and bind them to variables. In that construct, each variable is of the type of the set elements.

\begin{center}
\AxiomC{$\{ \vdash e_i:T \}_{i \in [1..n]} $} \AxiomC{$\vdash s:Set(T)$}
\LeftLabel{(SELECTION1)}
\BIC{$\vdash e_1,e_2,...e_n \texttt{ of } s$}
\DP
\end{center}

A selection operation can also be done within a constructor type \texttt{C}, i.e. it will select instances that has been constructed through this constructor.

\begin{center}
\AxiomC{$\{ \vdash e_i:C \}_{i \in [1..n]} $}
\LeftLabel{(SELECTION2)}
\UIC{$\vdash e_1,e_2,...e_n \texttt{ of }(\texttt{C}:Set(C))$}
\DP
\end{center}

\bibliographystyle{plain}	% (uses file "plain.bst")
\bibliography{ini_language_specs}		% expects file "ini_manual.bib"

\end{document}

