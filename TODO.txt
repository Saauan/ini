

Map to Pi Calculus (https://en.wikipedia.org/wiki/%CE%A0-calculus)

process main() {
	@init() {
		p1(x)
		p2(x)
		p3(x)
	}
}

process p1(x) {
	@init() {
		produce(x, "z");
	}
}

process p2(x) {
	c:@consume[channel=x](y) {
		produce(y, x)
		// anonymous process...
		process(x) {
			c:@consume[channel=x](y) {
				stop(c)
			}
		}(x)
		stop(c)
	}
}

process p3(x) {
	c:@consume[channel="z"](v) {
		produce(v, v)
		stop(c)
	}
}

```





Nokia Java ME

http://library.forum.nokia.com/index.jsp?topic=/Java_Developers_Library/GUID-660EC670-B7DB-4005-BF2D-411E5C0B3867_overview-d0e41497.html

Introduction to Mobile Sensor API

Mobile Sensor API (JSR-256) is an optional API that allows MIDlets to fetch data from sensors on a mobile device.

Mobile Sensor API is supported in the Symbian platform with clarifications detailed in Mobile Sensor API Implementation Notes. The API was first included on selected S60 3rd Edition FP 2 devices and S60 5th Edition (Java Runtime 1.4) devices. From Symbian^3 onwards, all devices include support for the API.

Different devices based on the Symbian platform may have different sensors available. To find out whether the chosen device supports the required sensors, see Device Specifications at Forum Nokia web site.

A sensor consists of one or more channels. A channel is an individual data measurement source. For example, an accelerometer sensor receives acceleration data from three channels, each of which is responsible for a single axis (x, y and z).

Sensors can be roughly divided into two types:

    * Sensors with a given range and accuracy for returned values, such as a sensor that measures the current network field intensity as a percentage value.
    * Binary on/off indicators, such as a sensor that notifies whether the device is currently connected to a battery charger.

All sensors have the following common properties:

    * Maximum value
    * Minimum value
    * Accuracy

Glossary

The Mobile Sensor API uses the following terms when referring to sensor properties:

unit The unit of the returned value, usually in SI units.

scale The sensor unit scale as an exponent of ten. For example, unit of meter and scale of -3 generates millimeters.

validity A boolean that verifies that the measured data value has been received and that it is valid.

uncertainty The estimated error in the measured data value. Uncertainty is given as the scale that is within 
one standard deviation of the measured value. Higher values signify higher uncertainty.

accuracy Relative measurement error of the sensor channel as a percentage value. The returned value is between 0..1 where 0 is fully accurate.



Finding and identifying sensors

To start using the Mobile Sensor API, you need to find the available sensors to be used. 
This is done with the SensorManager.findSensors() method. You can find the sensor by specifying 
quantity or context, or by entering a definite sensor URL describing desired sensor properties. 
These are described in the following example:

// Find all sensors
SensorInfo[] sensorInfos = SensorManager.findSensors( null, null );

// Find all "acceleration" sensors, the contextType is left undefined
SensorInfo[] sensorInfos = SensorManager.findSensors( "acceleration",  null );

// Or with URL
SensorInfo[] sensorInfos = SensorManager.findSensors( "sensor:acceleration" );

Depending on the search parameters, findSensors() can return several matching SensorInfo objects. 
To find the correct sensor, you may need to refine your search further by some of the following criteria:

The data type of the channel. This is one of the most useful criteria as it is very common for channels to use different data types.

    * TYPE_INT
    * TYPE_DOUBLE
    * TYPE_OBJECT

Unit The unit in which data values are presented. These are usually derived from the Unit class.
	


All measurement ranges for this channel. Measurement ranges are the resolution and the possible largest and smallest values of the sensor.
	
The context type of the sensor. Context divides sensor types into four categories depending on the environment where they are used.

    * USER
    * DEVICE
    * AMBIENT
    * VEHICLE

Model The model of the sensor specified by vendor specific. Returns the sensor model as a String

URL The URL of the sensor. It starts with the sensor: prefix and contains at least the quantity, model, and context type of the sensor.
Returns the URL as a String

For a full list of searchable criteria, see ChannelInfo and SensorInfo.
Example: identifying data types

The following code example determines the amount of available channels in the 
sensor and handles them according to data type. The example uses the DataListener 
interface to retrieve the sensor data. See section Using data listeners for more 
information.

public void dataReceived(SensorConnection sensor, Data[] data, boolean isDataLost ) {
    ChannelInfo[] channelinfo = sensor.getSensorInfo().getChannelInfos();
    for(int i = 0; i < channelinfo.length; i++) {
        switch (channelinfo[i].getDataType()) {
            case ChannelInfo.TYPE_INT:
                displayData(data[i].getIntValues());
                break;
            case ChannelInfo.TYPE_DOUBLE:
                displayData(data[i].getDoubleValues());
                break;
            case ChannelInfo.TYPE_OBJECT:
                displayData(data[i].getObjectValues());
                break;
        }
    }
}

**********
Opening a sensor connection

After finding the correct SensorInfo object, you can determine the s
ensor URL with the method getUrl().

A sensor connection is opened with the javax.microedition.io.Connector.open() 
method with the sensor URL is given as a parameter, such as in the following 
example:

SensorConnection sensorConnection;
try
{
sensorConnection = ( SensorConnection ) Connector.open( sensorInfo.getUrl() );
 	}
catch ( IOException e )
{
// Handle Exception if Connector.open() fails
}

The sensor connection can be opened directly without using findSensors() when 
the sensor URL is known. For maximum compatibility between different devices 
and implementations, try to select the sensor as precisely as possible. 
For example, on the Symbian platform the URL sensor:acceleration matches 
two different versions of the accelerometer: one providing double values 
presented in m/s^2 and another providing raw integer values from the sensor.

**********
Retrieving data from sensor

Retrieving data from a sensor in synchronous mode is done with SensorConnection.getData() method.

int bufferSize = 10;
Data[] data = sensorConnection.getData( bufferSize );

int bufferingPeriod = 1000;
boolean includeTimestamps = true;
boolean includeUncertainities = true;
boolean includeValidities = true;
Data[] data = sensorConnection.getData( bufferSize, bufferingPeriod, 
includeTimestamps, includeUncertainities, 
includeValidities );

SensorConnection.getData() returns the collected data of all the channels of the sensor, so 
the returned array will contain as many Data objects as there are channels. Data values can 
be accessed by using getIntValues(), getDoubleValues() or getObjectValues() methods of 
the Data object. Data object returns only the value type defined by the channel, 
otherwise it throws an IllegalStateException.

double[] doubleValues;
int[] intValues;
Data[] data = sensorConnection.getData( bufferSize );
if( data[0].getChannelInfo().getDataType() == ChannelInfo.TYPE_DOUBLE )
	{
	// Get double values
	doubleValues = data[0].getDoubleValues();
	}
else if( data[0].getChannelInfo().getDataType() == ChannelInfo.TYPE_INT )
	{
	// Get int values
	intValues = data[0].getIntValues();
	}

***********
Using data listeners

Data from a sensor can be retrieved in an asynchronous mode by implementing a DataListener interface.

class MyDataListener implements DataListener
    {
    public void dataReceived( SensorConnection aConnection, Data[] aData, boolean aIsDataLost )
        {
        // store received data
        }    
    }

DataListener.dataReceived() gets a similar Data object array as the getData() output. 
It also receives the SensorConnection from which the data was received and a boolean 
flag indicating whether data was lost between this and the previous data delivery.

Data listening is started by calling the method SensorConnection.setDataListener() and 
stopped by calling the SensorConnection.removeDataListener() method. Each SensorConnection 
can have only one DataListener. If setDataListener() is called when SensorConnection 
already has a registered DataListener, the previous listener will be replaced and data 
listening parameters are updated.

MyDataListener datalistener = new MyDataListener();

int bufferSize = 10;
sensorConnection.setDataListener( dataListener, bufferSize );
...

int bufferingPeriod = 1000;
boolean includeTimestamps = true;
boolean includeUncertainities = false;
boolean includeValidities = false;
sensorConnection.setDataListener( dataListener, bufferSize, bufferingPeriod, includeTimestamps, includeUnvertainities, includeValities );
....

sensorConnection.removeDataListener();

The implemented dataReceived() method should return quickly, so it should only store 
the received data and signal some other thread to do the more time consuming processing.


************

Using condition listening

Conditions can be used to get notifications when a certain sensor channel value meets 
specified criteria. When these criteria are met, the ConditionListener receives a conditionMet() notification:

class MyConditionListener implements ConditionListener
{
public void conditionMet( SensorConnection aConnection, Data aData, Condition aCondition )
	{
// signal worker thread or do something else
}
	}

Unlike SensorConnection.getData() or DataListener.dataReceived(), conditionMet() 
returns only a single Data object. This Data object contains the following values:

    *

      data value that met the condition
    *

      timestamp
    *

      uncertainty
    *

      validity

In addition to Data, the associated SensorConnection and Condition objects are received.

Condition listening is also different from data listening in how the condition 
listeners are assigned to a specific sensor channel. To start condition listening a 
ConditionListener, create a Condition object and add it with the Channel.addCondition() method.

// Create ConditionListener and LimitCondition
MyConditionListener conditionListener = new MyConditionListener();
LimitCondition condition = new LimitCondition(10, Condition.OP_GREATER_THAN );

// Get first channel of the sensor
ChannelInfo[] channelInfos = sensorConnection.getSensorInfo().getChannelInfos();
Channel channel = sensorConnection.getChannel( channelInfos[0] );

// Add condition listener and condition to channel
channel.addCondition( conditionListener, condition );

The ConditionListener is notified only once per a met condition. This prevents 
condition listeners from being flooded with notifications, because successive 
data values are very likely to meet the same condition. To receive more notifications, 
client has to add the ConditionListener and the Condition again with the Channel.addCondition() method.


    
